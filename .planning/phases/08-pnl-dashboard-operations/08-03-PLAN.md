---
phase: 08-pnl-dashboard-operations
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - bot/src/run-arb-mainnet.ts
  - bot/src/dashboard/report-cli.ts
  - package.json
autonomous: true
requirements:
  - TRACK-03
  - TRACK-04
  - OPS-03

must_haves:
  truths:
    - "On bot startup, session stats (lifetime trades, win rate, net P&L with three-bucket breakdown) display in the console"
    - "During operation, stats update periodically (every 5 minutes) without disrupting monitoring"
    - "Running `pnpm report` prints last 10 trades and exits without disrupting the running bot process"
    - "After running for 1+ hours with multiple trades, stats persist across pm2 restart"
  artifacts:
    - path: "bot/src/run-arb-mainnet.ts"
      provides: "TradeStore integration with startup stats display and periodic updates"
      contains: "TradeStore"
    - path: "bot/src/dashboard/report-cli.ts"
      provides: "CLI tool for printing last N trades from TradeStore"
      min_lines: 60
    - path: "package.json"
      provides: "npm script for report CLI"
      contains: "report"
  key_links:
    - from: "bot/src/run-arb-mainnet.ts"
      to: "bot/src/dashboard/TradeStore.ts"
      via: "import TradeStore and initialize on startup"
      pattern: "new TradeStore"
    - from: "bot/src/dashboard/report-cli.ts"
      to: "bot/src/dashboard/TradeStore.ts"
      via: "import TradeStore for read-only queries"
      pattern: "import.*TradeStore"
    - from: "package.json"
      to: "bot/src/dashboard/report-cli.ts"
      via: "report script executes report-cli.ts"
      pattern: "report-cli\\.ts"
---

<objective>
Integrate TradeStore into the bot with startup stats display, periodic updates, and a standalone --report CLI tool for querying trade history.

Purpose: Operators need visibility into bot performance without stopping the process. Startup stats show lifetime P&L and win rate from prior sessions. Periodic stats (every 5 minutes) show progress during long runs. The --report CLI provides on-demand trade history without disrupting the running bot.

Output: Updated run-arb-mainnet.ts with TradeStore integration, report-cli.ts for standalone queries, and npm script for convenience.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@bot/src/run-arb-mainnet.ts
@bot/src/index.ts
@bot/src/dashboard/TradeStore.ts
@bot/src/dashboard/types.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate TradeStore into run-arb-mainnet.ts with startup and periodic stats</name>
  <files>bot/src/run-arb-mainnet.ts</files>
  <action>
Update `bot/src/run-arb-mainnet.ts` to:
1. Initialize TradeStore on startup
2. Display session stats on startup (lifetime trades, win rate, net P&L with three-bucket breakdown)
3. Display stats periodically during operation (every 5 minutes)
4. Record trade outcomes when opportunities are found (DRY_RUN mode only logs them, live mode will record actual trades in Phase 7)

**Step 1: Import TradeStore at the top of the file**

```typescript
import { TradeStore } from "./dashboard/TradeStore.js";
import type { TradeOutcome } from "./dashboard/types.js";
```

**Step 2: Initialize TradeStore in main() before bot startup**

```typescript
async function main(): Promise<void> {
  // Load chain config using chainId 42161 (Arbitrum One)
  const chain = loadChainConfig(42161);

  // Initialize TradeStore
  const tradeStore = new TradeStore(); // Uses default path: .data/trades.jsonl

  // ... existing RPC status checks ...

  console.log(c.cyan(`\n========================================`));
  console.log(c.cyan(`  Flashloan Bot v${BOT_VERSION} — ARBITRUM ONE`));
  console.log(c.cyan(`  Report-only (no transactions)`));
  // ... existing startup banner ...
  console.log(c.cyan(`========================================\n`));

  // Display session stats on startup
  const sessionStats = tradeStore.getStats();
  if (sessionStats.totalTrades > 0) {
    console.log(c.bold(`\n[SESSION STATS] Lifetime Performance`));
    console.log(c.cyan(`  Total trades:    ${sessionStats.totalTrades}`));
    console.log(c.cyan(`  Success:         ${sessionStats.successCount} (${(sessionStats.winRate * 100).toFixed(1)}% win rate)`));
    console.log(c.cyan(`  Reverts:         ${sessionStats.revertCount}`));
    console.log(c.cyan(`  Sim reverts:     ${sessionStats.simulationRevertCount}`));
    console.log(c.cyan(`  ────────────────────────────────────────`));
    console.log(c.cyan(`  Gross profit:    ${sessionStats.grossProfitEth.toFixed(6)} ETH`));
    console.log(c.cyan(`  Gas cost (L2):   ${sessionStats.gasCostEth.toFixed(6)} ETH`));
    console.log(c.cyan(`  L1 data fee:     ${sessionStats.l1DataFeeEth.toFixed(6)} ETH`));
    console.log(c.cyan(`  Revert cost:     ${sessionStats.revertCostEth.toFixed(6)} ETH`));
    console.log(c.cyan(`  ────────────────────────────────────────`));
    const netColor = sessionStats.netProfitEth >= 0 ? c.green : c.red;
    console.log(netColor(`  Net P&L:         ${sessionStats.netProfitEth.toFixed(6)} ETH`));
    console.log(c.cyan(`\n`));
  } else {
    console.log(c.dim(`\n[SESSION STATS] No trades yet (first run)\n`));
  }

  // ... existing RPC guard and bot construction ...
}
```

**Step 3: Add periodic stats display (every 5 minutes)**

After the existing `const statsInterval = setInterval(logStats, 60_000);` line, add a second interval for trade stats:

```typescript
// ---- Stats intervals ----
const priceStatsInterval = setInterval(logStats, 60_000); // Existing price/opportunity stats every 60s

const tradeStatsInterval = setInterval(() => {
  const sessionStats = tradeStore.getStats();
  if (sessionStats.totalTrades > 0) {
    console.log(c.bold(`\n[SESSION UPDATE] Trade Stats`));
    console.log(c.cyan(`  Total: ${sessionStats.totalTrades} | Win rate: ${(sessionStats.winRate * 100).toFixed(1)}%`));
    const netColor = sessionStats.netProfitEth >= 0 ? c.green : c.red;
    console.log(netColor(`  Net P&L: ${sessionStats.netProfitEth.toFixed(6)} ETH`));
    console.log(c.dim(`  (Gross: ${sessionStats.grossProfitEth.toFixed(6)} | Gas: ${sessionStats.gasCostEth.toFixed(6)} | L1: ${sessionStats.l1DataFeeEth.toFixed(6)} | Revert: ${sessionStats.revertCostEth.toFixed(6)})`));
    console.log(c.cyan(``));
  }
}, 300_000); // Every 5 minutes
```

**Step 4: Update shutdown handler to clear both intervals**

In the `shutdown()` function, update the interval clearing:

```typescript
const shutdown = async (): Promise<void> => {
  if (shuttingDown) return;
  shuttingDown = true;

  console.log(c.bold(`\n[${ts()}] [SHUTDOWN] Stopping Arbitrum One monitor...`));
  clearInterval(priceStatsInterval);
  clearInterval(tradeStatsInterval);
  await bot.stop();

  // Display final session stats
  const finalStats = tradeStore.getStats();
  if (finalStats.totalTrades > 0) {
    console.log(c.bold(`\n[${ts()}] [SHUTDOWN] Final Session Stats:`));
    console.log(c.cyan(`  Total trades: ${finalStats.totalTrades} | Win rate: ${(finalStats.winRate * 100).toFixed(1)}%`));
    const netColor = finalStats.netProfitEth >= 0 ? c.green : c.red;
    console.log(netColor(`  Net P&L: ${finalStats.netProfitEth.toFixed(6)} ETH`));
  }

  console.log(c.bold(`\n[${ts()}] [SHUTDOWN] Final stats:`));
  logStats();
  process.exit(0);
};
```

**Step 5: Record trade outcomes in opportunityFound listener (dry-run mode simulation)**

In dry-run mode, we simulate trade outcomes for demonstration purposes. In Phase 7 (Live Execution), this will be replaced with actual transaction results.

For now, add a comment and skeleton for trade recording:

```typescript
// Opportunities found (green = would execute, yellow = unprofitable)
bot.detector.on("opportunityFound", (opp: ArbitrageOpportunity) => {
  stats.opportunitiesFound++;
  const profitable = opp.netProfit > 0;
  const col = profitable ? c.green : c.yellow;
  const tag = profitable ? "OPPORTUNITY" : "OPPORTUNITY (unprofitable)";

  // ... existing log output ...

  // TODO (Phase 7): Record actual trade outcomes after execution
  // For now, in dry-run mode, we just log. In Phase 7, after broadcasting a transaction,
  // record the outcome with tradeStore.append({ txHash, timestamp, blockNumber, ... })
  // based on transaction receipt and profit calculation.
});
```

**Do NOT** add actual trade recording logic yet. That happens in Phase 7 when live execution is implemented. This task only integrates the display and periodic stats.

**Rename the existing `statsInterval` variable to `priceStatsInterval`** to distinguish it from the new `tradeStatsInterval`.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes with no type errors
2. `grep -q "import.*TradeStore" bot/src/run-arb-mainnet.ts` — confirms TradeStore import
3. `grep -q "new TradeStore" bot/src/run-arb-mainnet.ts` — confirms TradeStore initialization
4. `grep -q "SESSION STATS" bot/src/run-arb-mainnet.ts` — confirms startup stats display
5. `grep -q "300_000" bot/src/run-arb-mainnet.ts` — confirms 5-minute interval
6. Two distinct interval variables exist: `priceStatsInterval` and `tradeStatsInterval`
  </verify>
  <done>
run-arb-mainnet.ts initializes TradeStore, displays session stats on startup, shows periodic updates every 5 minutes, and displays final stats on shutdown. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create standalone report CLI tool for querying trade history</name>
  <files>bot/src/dashboard/report-cli.ts</files>
  <action>
Create `bot/src/dashboard/report-cli.ts` as a standalone CLI tool that reads the TradeStore and prints the last N trades.

**Design:**
- Read-only access to `.data/trades.jsonl` (no modifications)
- Accepts `--last N` flag to control how many trades to show (default: 10)
- Displays trades in reverse chronological order (most recent first)
- Shows three-bucket breakdown for each trade
- Exits after printing (does NOT block or watch for changes)

**File content:**

```typescript
#!/usr/bin/env node
import "dotenv/config";
import { TradeStore } from "./TradeStore.js";
import type { TradeOutcome } from "./types.js";

// ANSI colors (same helpers as run-arb-mainnet.ts)
const c = {
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  red: (s: string) => `\x1b[31m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  dim: (s: string) => `\x1b[2m${s}\x1b[0m`,
  bold: (s: string) => `\x1b[1m${s}\x1b[0m`,
};

function formatTradeOutcome(trade: TradeOutcome, index: number): string {
  const statusColor = trade.status === "success" ? c.green : trade.status === "revert" ? c.red : c.yellow;
  const netColor = trade.netProfit >= 0 ? c.green : c.red;

  const date = new Date(trade.timestamp).toISOString();

  let output = statusColor(`\n[${ index + 1}] ${trade.status.toUpperCase()} — ${date}\n`);
  output += c.dim(`    TxHash:       ${trade.txHash}\n`);
  output += c.dim(`    Block:        ${trade.blockNumber}\n`);
  output += c.cyan(`    Path:         ${trade.path}\n`);
  output += c.cyan(`    Input:        ${trade.inputAmount.toFixed(4)} ETH\n`);
  output += c.cyan(`    ────────────────────────────────────────\n`);
  output += c.cyan(`    Gross profit: ${trade.grossProfit.toFixed(6)} ETH\n`);
  output += c.cyan(`    Gas (L2):     ${trade.gasCost.toFixed(6)} ETH\n`);
  output += c.cyan(`    L1 data fee:  ${trade.l1DataFee.toFixed(6)} ETH\n`);
  output += c.cyan(`    Revert cost:  ${trade.revertCost.toFixed(6)} ETH\n`);
  output += c.cyan(`    ────────────────────────────────────────\n`);
  output += netColor(`    Net P&L:      ${trade.netProfit.toFixed(6)} ETH\n`);

  return output;
}

function main(): void {
  // Parse CLI args
  const args = process.argv.slice(2);
  let lastN = 10; // Default: last 10 trades

  for (let i = 0; i < args.length; i++) {
    if (args[i] === "--last" && args[i + 1]) {
      lastN = parseInt(args[i + 1], 10);
      if (isNaN(lastN) || lastN < 1) {
        console.error(c.red(`[ERROR] --last must be a positive integer`));
        process.exit(1);
      }
      i++; // Skip next arg (already consumed)
    } else if (args[i] === "--help" || args[i] === "-h") {
      console.log(`
${c.bold("Flashloan Bot — Trade Report CLI")}

Usage:
  pnpm report [--last N]

Options:
  --last N    Show last N trades (default: 10)
  --help      Show this help message

Examples:
  pnpm report              # Show last 10 trades
  pnpm report --last 20    # Show last 20 trades
`);
      process.exit(0);
    } else {
      console.error(c.red(`[ERROR] Unknown argument: ${args[i]}`));
      console.error(c.dim(`Run with --help for usage info`));
      process.exit(1);
    }
  }

  // Load TradeStore
  const store = new TradeStore();

  // Get session stats
  const stats = store.getStats();

  // Print header
  console.log(c.bold(`\n========================================`));
  console.log(c.bold(`  Flashloan Bot — Trade Report`));
  console.log(c.bold(`========================================\n`));

  console.log(c.cyan(`Total trades:    ${stats.totalTrades}`));
  console.log(c.cyan(`Success:         ${stats.successCount} (${(stats.winRate * 100).toFixed(1)}% win rate)`));
  console.log(c.cyan(`Reverts:         ${stats.revertCount}`));
  console.log(c.cyan(`Sim reverts:     ${stats.simulationRevertCount}`));
  console.log(c.cyan(`────────────────────────────────────────`));
  console.log(c.cyan(`Gross profit:    ${stats.grossProfitEth.toFixed(6)} ETH`));
  console.log(c.cyan(`Gas cost (L2):   ${stats.gasCostEth.toFixed(6)} ETH`));
  console.log(c.cyan(`L1 data fee:     ${stats.l1DataFeeEth.toFixed(6)} ETH`));
  console.log(c.cyan(`Revert cost:     ${stats.revertCostEth.toFixed(6)} ETH`));
  console.log(c.cyan(`────────────────────────────────────────`));
  const netColor = stats.netProfitEth >= 0 ? c.green : c.red;
  console.log(netColor(`Net P&L:         ${stats.netProfitEth.toFixed(6)} ETH`));

  // Print recent trades
  const trades = store.getLast(lastN);

  if (trades.length === 0) {
    console.log(c.dim(`\nNo trades yet.\n`));
    return;
  }

  console.log(c.bold(`\n\nLast ${trades.length} trade(s):\n`));

  for (let i = 0; i < trades.length; i++) {
    console.log(formatTradeOutcome(trades[i], i));
  }

  console.log(c.dim(`\n(Showing ${trades.length} of ${stats.totalTrades} total trades)\n`));
}

main();
```

**Key features:**
1. **--last N flag** — Control how many trades to show
2. **--help flag** — Usage instructions
3. **Read-only** — No modifications to the TradeStore
4. **Standalone** — No bot initialization, just read + print + exit
5. **Three-bucket display** — Shows gross/gas/l1/revert breakdown per trade
6. **Reverse chronological** — Most recent trades first

**Shebang** (`#!/usr/bin/env node`) allows direct execution if permissions are set, but not required for `tsx` or `pnpm` script execution.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes with no type errors
2. File exists at `bot/src/dashboard/report-cli.ts`
3. `grep -q "TradeStore" bot/src/dashboard/report-cli.ts` — confirms TradeStore import
4. `grep -q "\\-\\-last" bot/src/dashboard/report-cli.ts` — confirms --last flag support
  </verify>
  <done>
report-cli.ts exists as a standalone CLI tool that reads TradeStore, prints last N trades with three-bucket breakdown, and exits. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add report npm script to package.json</name>
  <files>package.json</files>
  <action>
Add an npm script to `package.json` for running the report CLI tool.

**Add to the `"scripts"` section:**

```json
{
  "scripts": {
    // ... existing scripts ...

    "report": "tsx bot/src/dashboard/report-cli.ts",
    "report:last": "tsx bot/src/dashboard/report-cli.ts --last"
  }
}
```

**Usage:**
- `pnpm report` — Show last 10 trades (default)
- `pnpm report:last 20` — Show last 20 trades

**Place these scripts near the bot:* scripts** (e.g., after `bot:arb-mainnet` or similar). Keep the script section organized.

**Verify JSON is valid** by ensuring commas are correct (no trailing comma on last script).
  </action>
  <verify>
1. `cat package.json | grep "\"report\""` — confirms report script exists
2. `cat package.json | grep "report-cli.ts"` — confirms script points to report-cli.ts
3. `node -e "JSON.parse(require('fs').readFileSync('package.json', 'utf-8'))"` — JSON is valid
  </verify>
  <done>
package.json has `report` and `report:last` scripts pointing to report-cli.ts. JSON is valid.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` — no type errors in run-arb-mainnet.ts or report-cli.ts
2. `grep -q "SESSION STATS" bot/src/run-arb-mainnet.ts` — confirms startup stats display
3. `grep -q "300_000" bot/src/run-arb-mainnet.ts` — confirms 5-minute periodic stats
4. `cat package.json | grep "\"report\""` — confirms report script exists
5. `pnpm test` — all existing tests still pass (no regressions)
6. Manual test: `pnpm report --help` shows usage (after implementation)
</verification>

<success_criteria>
run-arb-mainnet.ts displays session stats on startup and every 5 minutes. report-cli.ts provides standalone trade history queries. package.json has report npm script. All tests pass. Operators can monitor bot performance without stopping the process.
</success_criteria>

<output>
After completion, create `.planning/phases/08-pnl-dashboard-operations/08-03-SUMMARY.md`
</output>
