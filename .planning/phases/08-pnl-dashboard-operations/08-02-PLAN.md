---
phase: 08-pnl-dashboard-operations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ecosystem.config.cjs
  - package.json
autonomous: true
requirements:
  - OPS-01
  - OPS-02

must_haves:
  truths:
    - "Bot runs as a pm2-managed process with auto-restart on crash"
    - "Ecosystem config uses .cjs extension for ESM compatibility with node --import tsx interpreter"
    - "Bot logs rotate automatically to prevent disk fill"
    - "Process auto-restarts if memory exceeds 500MB (runaway memory protection)"
  artifacts:
    - path: "ecosystem.config.cjs"
      provides: "PM2 ecosystem config for fork mode with tsx interpreter and memory limits"
      min_lines: 40
    - path: "package.json"
      provides: "npm scripts for pm2 start/stop/logs/restart commands"
      contains: "pm2"
  key_links:
    - from: "ecosystem.config.cjs"
      to: "bot/src/run-arb-mainnet.ts"
      via: "script property pointing to entry point"
      pattern: "run-arb-mainnet\\.ts"
    - from: "package.json"
      to: "ecosystem.config.cjs"
      via: "pm2 start ecosystem.config.cjs script"
      pattern: "pm2 start ecosystem\\.config\\.cjs"
---

<objective>
Create PM2 ecosystem config with .cjs extension for ESM compatibility, fork mode, tsx interpreter, log rotation, and memory-based auto-restart.

Purpose: The bot must run unattended for 24+ hours on Arbitrum mainnet. PM2 provides process management with auto-restart on crash, log rotation to prevent disk fill, and memory-based restart to catch runaway leaks. The ecosystem config MUST use .cjs extension (not .js) to avoid ESM/CommonJS conflicts with `node --import tsx` interpreter.

Output: ecosystem.config.cjs file and package.json scripts for pm2 operations.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@bot/src/run-arb-mainnet.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PM2 ecosystem config with .cjs extension</name>
  <files>ecosystem.config.cjs</files>
  <action>
Create `ecosystem.config.cjs` at the project root with PM2 configuration for running the Arbitrum mainnet bot in fork mode.

**Critical requirements from research:**
- **File extension MUST be .cjs** — NOT .js. ESM projects with `"type": "module"` in package.json require .cjs extension for CommonJS config files.
- **Interpreter MUST be 'node'** — NOT 'tsx'. Use `interpreter: 'node'` with `interpreter_args: '--import tsx'` for ESM+TypeScript support.
- **Fork mode ONLY** — NEVER cluster mode. Nonce conflicts occur if multiple processes share the same wallet.

**Config file content:**

```javascript
module.exports = {
  apps: [
    {
      name: "flashloaner-arb",
      script: "bot/src/run-arb-mainnet.ts",
      interpreter: "node",
      interpreter_args: "--import tsx",

      // Fork mode (NOT cluster — nonce conflicts)
      instances: 1,
      exec_mode: "fork",

      // Auto-restart on crash
      autorestart: true,
      max_restarts: 10,             // Max restarts within restart window
      min_uptime: "10s",            // Consider crashed if exits within 10s
      restart_delay: 5000,          // 5s delay before restart

      // Memory-based restart (runaway memory protection)
      max_memory_restart: "500M",

      // Graceful shutdown
      kill_timeout: 10000,          // 10s graceful shutdown timeout (SIGTERM -> SIGKILL)

      // Log rotation
      error_file: ".data/logs/err.log",
      out_file: ".data/logs/out.log",
      log_date_format: "YYYY-MM-DD HH:mm:ss Z",
      merge_logs: true,

      // Environment (inherit from shell, allow .env override)
      env: {
        NODE_ENV: "production",
        // PM2 will inherit RPC_URL, PRIVATE_KEY, etc. from shell environment
        // Users can override with `pm2 start ecosystem.config.cjs --update-env` after changing .env
      },

      // Watch mode DISABLED for production (use pm2 restart for updates)
      watch: false,

      // Time zone (UTC for consistent logs)
      time: true,
    },
  ],
};
```

**Key design choices:**

1. **Fork mode, instances: 1** — Prevents nonce collision. Only one process can sign transactions with a given private key at a time.

2. **Memory limit: 500M** — If the bot exceeds 500MB memory (runaway leak), pm2 auto-restarts. Typical bot usage is <100MB, so 500MB is a safe buffer that catches real leaks.

3. **Graceful shutdown: 10s** — The bot's shutdown handler (in run-arb-mainnet.ts) has time to log final stats and stop cleanly. If shutdown exceeds 10s, pm2 sends SIGKILL.

4. **Log rotation via pm2-logrotate** — The config points to `.data/logs/` directory. Users should install `pm2 install pm2-logrotate` for automatic rotation. Document this in the npm script description.

5. **Interpreter: node + --import tsx** — This is the ONLY way to run TypeScript ESM files with pm2. Using `interpreter: 'tsx'` fails because pm2 can't find the tsx binary. Using `node --import tsx` works because tsx registers on-the-fly TS compilation.

6. **env: NODE_ENV=production** — Signals production mode. The bot does NOT need DRY_RUN in the env block because live mode is the default (DRY_RUN=true is for dry-run mode).

7. **.cjs extension** — Required for ESM projects. PM2 loads this file as CommonJS (module.exports), not ESM (export default).

**Do NOT** add database config, API keys, or secrets to this file. Environment variables are inherited from the shell or .env file.
  </action>
  <verify>
1. File exists at `ecosystem.config.cjs` (NOT ecosystem.config.js)
2. `interpreter: "node"` and `interpreter_args: "--import tsx"` are present
3. `exec_mode: "fork"` and `instances: 1` are set
4. `max_memory_restart: "500M"` is set
5. Log paths point to `.data/logs/` directory
  </verify>
  <done>
File `ecosystem.config.cjs` exists at project root with fork mode, node+tsx interpreter, 500MB memory limit, and log rotation config.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add PM2 convenience scripts to package.json</name>
  <files>package.json</files>
  <action>
Add npm scripts to `package.json` for common PM2 operations: start, stop, restart, logs, and status.

**Add these scripts to the `"scripts"` section:**

```json
{
  "scripts": {
    // ... existing scripts ...

    "pm2:start": "pm2 start ecosystem.config.cjs",
    "pm2:stop": "pm2 stop flashloaner-arb",
    "pm2:restart": "pm2 restart flashloaner-arb",
    "pm2:logs": "pm2 logs flashloaner-arb --lines 100",
    "pm2:status": "pm2 status",
    "pm2:monit": "pm2 monit",
    "pm2:delete": "pm2 delete flashloaner-arb"
  }
}
```

**Script descriptions:**
- `pm2:start` — Starts the bot using the ecosystem config. First-time start or after `pm2:delete`.
- `pm2:stop` — Stops the bot gracefully (sends SIGTERM, waits for shutdown, keeps in pm2 list).
- `pm2:restart` — Restarts the bot (use after code changes or config updates).
- `pm2:logs` — Tail logs (last 100 lines + follow mode).
- `pm2:status` — Show pm2 process list (status, uptime, restarts, memory).
- `pm2:monit` — Real-time monitoring dashboard (CPU, memory, logs).
- `pm2:delete` — Remove bot from pm2 list (use before `pm2:start` to reset restart count).

**Also add a comment in the scripts section** above the pm2 scripts explaining log rotation setup:

```json
{
  "scripts": {
    // ... existing scripts ...

    "// PM2 Process Management": "Install pm2 globally: npm i -g pm2. For log rotation: pm2 install pm2-logrotate && pm2 set pm2-logrotate:max_size 10M && pm2 set pm2-logrotate:retain 7",
    "pm2:start": "pm2 start ecosystem.config.cjs",
    // ... rest of pm2 scripts ...
  }
}
```

**Also verify pm2 is in devDependencies** (it may already be there from prior setup). If not, add it:

```json
{
  "devDependencies": {
    "pm2": "^5.3.0"
  }
}
```

**Do NOT** run `pnpm install` in this task — just modify package.json. The verification step will validate the format.
  </action>
  <verify>
1. `cat package.json | grep pm2:start` shows the pm2:start script
2. `cat package.json | grep pm2:logs` shows the pm2:logs script
3. `cat package.json | grep pm2:status` shows the pm2:status script
4. JSON is valid: `node -e "JSON.parse(require('fs').readFileSync('package.json', 'utf-8'))"` succeeds
  </verify>
  <done>
package.json has 7 pm2:* scripts (start, stop, restart, logs, status, monit, delete) and a comment explaining log rotation setup. JSON is valid.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create .data/logs directory and add to .gitignore</name>
  <files>.gitignore</files>
  <action>
Ensure the `.data/logs/` directory is excluded from git (logs should never be committed) and create the directory structure.

**Step 1: Create .data/logs directory with .gitkeep**

```bash
mkdir -p .data/logs
touch .data/logs/.gitkeep
```

This ensures the directory exists for pm2 to write logs, and the .gitkeep file ensures the directory structure is tracked by git (but not the logs themselves).

**Step 2: Add .data/logs/ to .gitignore**

Check if `.gitignore` already has a `.data/` rule. If not, add:

```
# Data directory (JSONL persistence, pm2 logs)
.data/
!.data/logs/.gitkeep
```

The pattern `.data/` ignores everything in the data directory, and `!.data/logs/.gitkeep` un-ignores the .gitkeep file so the directory structure is tracked.

**If .gitignore already has a `.data/` rule**, verify it has the `!.data/logs/.gitkeep` exception. If not, add it.

**Verification approach:**
```bash
# Check if .data/ is already in .gitignore
grep -q "^.data/" .gitignore && echo "Already ignored" || echo "Not ignored"

# Check if .gitkeep exception exists
grep -q "!.data/logs/.gitkeep" .gitignore && echo "Exception exists" || echo "Exception missing"
```

If `.data/` is already ignored but the exception is missing, add the exception line.

**Do NOT** commit .data/trades.jsonl or any log files. Only .gitkeep should be tracked.
  </action>
  <verify>
1. Directory exists: `ls -la .data/logs/.gitkeep` shows the file
2. .gitignore contains `.data/` rule
3. .gitignore contains `!.data/logs/.gitkeep` exception
4. `git check-ignore .data/logs/out.log` returns 0 (file is ignored)
5. `git check-ignore .data/logs/.gitkeep` returns 1 (file is NOT ignored — it's tracked)
  </verify>
  <done>
.data/logs directory exists with .gitkeep file. .gitignore excludes .data/ but tracks .gitkeep. PM2 can write logs to .data/logs/ without committing log files.
  </done>
</task>

</tasks>

<verification>
1. `node ecosystem.config.cjs` — file is valid CommonJS (no syntax errors)
2. `cat ecosystem.config.cjs | grep "interpreter.*node"` — confirms node interpreter (not tsx)
3. `cat ecosystem.config.cjs | grep "interpreter_args.*--import tsx"` — confirms tsx loading
4. `cat ecosystem.config.cjs | grep "exec_mode.*fork"` — confirms fork mode
5. `cat package.json | grep pm2:start` — confirms pm2 scripts exist
6. `ls -la .data/logs/.gitkeep` — confirms log directory structure
7. `git check-ignore .data/logs/out.log` returns 0 — confirms logs are gitignored
</verification>

<success_criteria>
PM2 ecosystem config exists as ecosystem.config.cjs with fork mode, node+tsx interpreter, 500MB memory limit, and log rotation. package.json has 7 pm2 convenience scripts. .data/logs directory exists with .gitkeep tracked by git. Bot can run via `pnpm pm2:start` and operate unattended.
</success_criteria>

<output>
After completion, create `.planning/phases/08-pnl-dashboard-operations/08-02-SUMMARY.md`
</output>
