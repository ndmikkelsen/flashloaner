---
phase: 08-pnl-dashboard-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/src/dashboard/TradeStore.ts
  - bot/src/dashboard/types.ts
  - bot/__tests__/dashboard/trade-store.test.ts
autonomous: true
requirements:
  - TRACK-01
  - TRACK-02

must_haves:
  truths:
    - "After a profitable trade, revert, or gas-only loss, the trade outcome persists to disk at .data/trades.jsonl"
    - "After process restart, TradeStore loads all prior trades from disk and makes them available for queries"
    - "Trade records separate gross profit, gas cost (including L1 data fee), and revert cost into three distinct fields"
  artifacts:
    - path: "bot/src/dashboard/TradeStore.ts"
      provides: "Trade persistence with JSONL append-only storage and three-bucket accounting"
      min_lines: 100
    - path: "bot/src/dashboard/types.ts"
      provides: "TradeOutcome type with three-bucket P&L fields"
      exports: ["TradeOutcome"]
    - path: "bot/__tests__/dashboard/trade-store.test.ts"
      provides: "Tests for persistence, restart recovery, and three-bucket accounting validation"
      min_lines: 80
  key_links:
    - from: "bot/src/dashboard/TradeStore.ts"
      to: ".data/trades.jsonl"
      via: "fs.appendFileSync for atomic appends"
      pattern: "appendFileSync.*trades\\.jsonl"
    - from: "bot/__tests__/dashboard/trade-store.test.ts"
      to: "bot/src/dashboard/TradeStore.ts"
      via: "import TradeStore"
      pattern: "import.*TradeStore"
---

<objective>
Create a TradeStore module with JSONL append-only persistence and three-bucket P&L accounting (gross profit, gas costs, revert costs) that survives process restarts.

Purpose: Every trade outcome must persist to disk with atomic append operations. Three-bucket accounting separates gross profit (what the trade made), gas costs including L1 data fees (what we paid to execute), and revert costs (gas burned on failed transactions), providing clear attribution for P&L analysis and operator decision-making.

Output: TradeStore module with JSONL file storage, three-bucket accounting types, and tests validating persistence across restarts.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@bot/src/index.ts
@bot/src/run-arb-mainnet.ts
@bot/src/detector/types.ts
@bot/src/monitor/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define TradeOutcome type with three-bucket P&L accounting</name>
  <files>bot/src/dashboard/types.ts</files>
  <action>
Create `bot/src/dashboard/types.ts` with the `TradeOutcome` type for three-bucket P&L accounting.

**Type definition:**

```typescript
export interface TradeOutcome {
  // Identifiers
  txHash: string;               // Transaction hash (or "simulation" for reverts caught in eth_call)
  timestamp: number;             // Unix timestamp in milliseconds
  blockNumber: number;           // Block where transaction was mined (or simulated block for reverts)

  // Trade details
  path: string;                  // Path label (e.g., "WETH/USDC UniV3 0.05% -> WETH/USDC UniV3 0.3%")
  inputAmount: number;           // Input amount in ETH

  // Three-bucket P&L accounting
  grossProfit: number;           // ETH profit before costs (can be negative if simulation caught a loss)
  gasCost: number;               // L2 gas cost in ETH
  l1DataFee: number;             // L1 data fee in ETH (Arbitrum-specific, 0 on L1-only chains)
  revertCost: number;            // Gas burned on reverted transaction (0 for successful trades)

  // Computed field
  netProfit: number;             // grossProfit - gasCost - l1DataFee - revertCost

  // Status
  status: "success" | "revert" | "simulation_revert";
  // "success": transaction mined and profitable
  // "revert": transaction mined but reverted on-chain (burned gas)
  // "simulation_revert": eth_call simulation caught unprofitability, transaction not broadcast
}
```

**Why three buckets:**
1. **grossProfit** — What the trade logic produced (DEX swap math). Shows if our price detection works.
2. **gasCost + l1DataFee** — What we paid to execute. Shows if our gas model is accurate. On Arbitrum, L1 data fees dominate (~95% of cost), so tracking separately is critical.
3. **revertCost** — Gas burned on failed transactions. Shows if our simulation is catching failures or letting bad trades through.

Net P&L = grossProfit - gasCost - l1DataFee - revertCost.

**Also export a helper type for stats aggregation (used in Plan 3):**

```typescript
export interface SessionStats {
  totalTrades: number;
  successCount: number;
  revertCount: number;
  simulationRevertCount: number;

  grossProfitEth: number;
  gasCostEth: number;
  l1DataFeeEth: number;
  revertCostEth: number;
  netProfitEth: number;

  winRate: number;              // successCount / totalTrades
  firstTradeTimestamp?: number;
  lastTradeTimestamp?: number;
}
```

Export both types from this file.
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes with no type errors. File exports `TradeOutcome` and `SessionStats`.
  </verify>
  <done>
File `bot/src/dashboard/types.ts` exists with `TradeOutcome` and `SessionStats` types. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement TradeStore with JSONL persistence and query methods</name>
  <files>bot/src/dashboard/TradeStore.ts</files>
  <action>
Create `bot/src/dashboard/TradeStore.ts` that persists trade outcomes to `.data/trades.jsonl` using append-only JSONL format.

**Design:**
- **Append-only JSONL**: Each trade = one JSON line appended to `.data/trades.jsonl`. Atomic, crash-safe, no corruption risk.
- **In-memory cache**: Load all trades on initialization into a `TradeOutcome[]` array for fast queries.
- **Auto-create directory**: If `.data/` doesn't exist, create it (using `fs.mkdirSync` with `recursive: true`).

**Class interface:**

```typescript
import * as fs from "node:fs";
import * as path from "node:path";
import type { TradeOutcome, SessionStats } from "./types.js";

export class TradeStore {
  private readonly filePath: string;
  private trades: TradeOutcome[] = [];

  constructor(filePath = ".data/trades.jsonl") {
    this.filePath = path.resolve(filePath);
    this.ensureDataDir();
    this.loadFromDisk();
  }

  /**
   * Append a trade outcome to disk and in-memory cache.
   * Atomic operation: append to file, then update cache.
   */
  append(trade: TradeOutcome): void {
    // Validate trade has required fields
    if (!trade.txHash || trade.timestamp === undefined || trade.blockNumber === undefined) {
      throw new Error("TradeOutcome missing required fields: txHash, timestamp, blockNumber");
    }

    // Append to file (atomic line write)
    const line = JSON.stringify(trade) + "\n";
    fs.appendFileSync(this.filePath, line, "utf-8");

    // Update in-memory cache
    this.trades.push(trade);
  }

  /**
   * Get all trades (chronological order).
   */
  getAll(): TradeOutcome[] {
    return [...this.trades];
  }

  /**
   * Get last N trades (most recent first).
   */
  getLast(n: number): TradeOutcome[] {
    return this.trades.slice(-n).reverse();
  }

  /**
   * Compute session stats from all trades.
   */
  getStats(): SessionStats {
    if (this.trades.length === 0) {
      return {
        totalTrades: 0,
        successCount: 0,
        revertCount: 0,
        simulationRevertCount: 0,
        grossProfitEth: 0,
        gasCostEth: 0,
        l1DataFeeEth: 0,
        revertCostEth: 0,
        netProfitEth: 0,
        winRate: 0,
      };
    }

    const successCount = this.trades.filter(t => t.status === "success").length;
    const revertCount = this.trades.filter(t => t.status === "revert").length;
    const simulationRevertCount = this.trades.filter(t => t.status === "simulation_revert").length;

    const grossProfitEth = this.trades.reduce((sum, t) => sum + t.grossProfit, 0);
    const gasCostEth = this.trades.reduce((sum, t) => sum + t.gasCost, 0);
    const l1DataFeeEth = this.trades.reduce((sum, t) => sum + t.l1DataFee, 0);
    const revertCostEth = this.trades.reduce((sum, t) => sum + t.revertCost, 0);
    const netProfitEth = this.trades.reduce((sum, t) => sum + t.netProfit, 0);

    const winRate = successCount / this.trades.length;

    return {
      totalTrades: this.trades.length,
      successCount,
      revertCount,
      simulationRevertCount,
      grossProfitEth,
      gasCostEth,
      l1DataFeeEth,
      revertCostEth,
      netProfitEth,
      winRate,
      firstTradeTimestamp: this.trades[0]?.timestamp,
      lastTradeTimestamp: this.trades[this.trades.length - 1]?.timestamp,
    };
  }

  /**
   * Clear all trades (for testing only — do NOT expose in production CLI).
   */
  clear(): void {
    this.trades = [];
    if (fs.existsSync(this.filePath)) {
      fs.unlinkSync(this.filePath);
    }
  }

  // ---- Private methods ----

  private ensureDataDir(): void {
    const dir = path.dirname(this.filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }

  private loadFromDisk(): void {
    if (!fs.existsSync(this.filePath)) {
      return; // No file yet — start fresh
    }

    const content = fs.readFileSync(this.filePath, "utf-8");
    const lines = content.split("\n").filter(line => line.trim().length > 0);

    for (const line of lines) {
      try {
        const trade = JSON.parse(line) as TradeOutcome;
        this.trades.push(trade);
      } catch (err) {
        // Corrupted line — log and skip (JSONL resilience)
        console.warn(`[TradeStore] Skipping corrupted line: ${line.slice(0, 50)}...`);
      }
    }
  }
}
```

**Key design choices:**
- **Append-only**: `fs.appendFileSync` is atomic on most filesystems. No risk of partial writes corrupting the file.
- **Resilience**: If a line is corrupted (malformed JSON), skip it with a warning instead of crashing.
- **Restart recovery**: `loadFromDisk()` runs on construction, so every new `TradeStore` instance gets all prior trades.

**Do NOT** add any better-sqlite3 code here. JSONL-only for v1.1. SQLite upgrade is deferred to v1.2.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes with no type errors
2. File exists at `bot/src/dashboard/TradeStore.ts`
3. Imports use `.js` extension for ESM compatibility (e.g., `from "./types.js"`)
4. No better-sqlite3 imports (JSONL only for v1.1)
  </verify>
  <done>
TradeStore class exists with JSONL persistence, append/getAll/getLast/getStats methods, and restart recovery. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for TradeStore persistence and restart recovery</name>
  <files>bot/__tests__/dashboard/trade-store.test.ts</files>
  <action>
Create `bot/__tests__/dashboard/trade-store.test.ts` with tests validating JSONL persistence, restart recovery, and three-bucket accounting.

**Test structure:**

```typescript
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import * as fs from "node:fs";
import { TradeStore } from "../../src/dashboard/TradeStore.js";
import type { TradeOutcome } from "../../src/dashboard/types.js";

const TEST_FILE = ".data/test-trades.jsonl";

describe("TradeStore", () => {
  beforeEach(() => {
    // Clean up test file before each test
    if (fs.existsSync(TEST_FILE)) {
      fs.unlinkSync(TEST_FILE);
    }
  });

  afterEach(() => {
    // Clean up test file after each test
    if (fs.existsSync(TEST_FILE)) {
      fs.unlinkSync(TEST_FILE);
    }
  });

  it("should create .data/ directory if it does not exist", () => {
    const testDir = ".data";
    if (fs.existsSync(testDir)) {
      fs.rmSync(testDir, { recursive: true });
    }

    const store = new TradeStore(TEST_FILE);
    expect(fs.existsSync(testDir)).toBe(true);

    store.clear(); // Clean up
  });

  it("should append a trade outcome and persist to disk", () => {
    const store = new TradeStore(TEST_FILE);

    const trade: TradeOutcome = {
      txHash: "0xabc123",
      timestamp: Date.now(),
      blockNumber: 12345,
      path: "WETH/USDC UniV3 0.05% -> WETH/USDC UniV3 0.3%",
      inputAmount: 1.0,
      grossProfit: 0.01,
      gasCost: 0.0001,
      l1DataFee: 0.0009,
      revertCost: 0,
      netProfit: 0.009,
      status: "success",
    };

    store.append(trade);

    // Verify in-memory
    expect(store.getAll()).toHaveLength(1);
    expect(store.getAll()[0]).toEqual(trade);

    // Verify on disk
    const content = fs.readFileSync(TEST_FILE, "utf-8");
    expect(content.trim()).toBe(JSON.stringify(trade));
  });

  it("should load trades from disk on restart", () => {
    // First instance: append 2 trades
    const store1 = new TradeStore(TEST_FILE);
    const trade1: TradeOutcome = {
      txHash: "0x111",
      timestamp: Date.now(),
      blockNumber: 100,
      path: "Path A",
      inputAmount: 1.0,
      grossProfit: 0.01,
      gasCost: 0.0001,
      l1DataFee: 0.0009,
      revertCost: 0,
      netProfit: 0.009,
      status: "success",
    };
    const trade2: TradeOutcome = {
      txHash: "0x222",
      timestamp: Date.now(),
      blockNumber: 101,
      path: "Path B",
      inputAmount: 2.0,
      grossProfit: -0.005,
      gasCost: 0.0001,
      l1DataFee: 0.0009,
      revertCost: 0.001,
      netProfit: -0.0069,
      status: "revert",
    };

    store1.append(trade1);
    store1.append(trade2);

    // Second instance: should load both trades
    const store2 = new TradeStore(TEST_FILE);
    expect(store2.getAll()).toHaveLength(2);
    expect(store2.getAll()[0]).toEqual(trade1);
    expect(store2.getAll()[1]).toEqual(trade2);
  });

  it("should compute correct session stats with three-bucket accounting", () => {
    const store = new TradeStore(TEST_FILE);

    const trade1: TradeOutcome = {
      txHash: "0xaaa",
      timestamp: 1000,
      blockNumber: 100,
      path: "Path A",
      inputAmount: 1.0,
      grossProfit: 0.02,
      gasCost: 0.0001,
      l1DataFee: 0.0009,
      revertCost: 0,
      netProfit: 0.019,
      status: "success",
    };

    const trade2: TradeOutcome = {
      txHash: "0xbbb",
      timestamp: 2000,
      blockNumber: 101,
      path: "Path B",
      inputAmount: 1.5,
      grossProfit: -0.005,
      gasCost: 0.0001,
      l1DataFee: 0.0009,
      revertCost: 0.001,
      netProfit: -0.0069,
      status: "revert",
    };

    const trade3: TradeOutcome = {
      txHash: "simulation",
      timestamp: 3000,
      blockNumber: 102,
      path: "Path C",
      inputAmount: 0.5,
      grossProfit: -0.01,
      gasCost: 0,
      l1DataFee: 0,
      revertCost: 0,
      netProfit: -0.01,
      status: "simulation_revert",
    };

    store.append(trade1);
    store.append(trade2);
    store.append(trade3);

    const stats = store.getStats();

    expect(stats.totalTrades).toBe(3);
    expect(stats.successCount).toBe(1);
    expect(stats.revertCount).toBe(1);
    expect(stats.simulationRevertCount).toBe(1);

    // Three-bucket totals
    expect(stats.grossProfitEth).toBeCloseTo(0.005, 6); // 0.02 - 0.005 - 0.01
    expect(stats.gasCostEth).toBeCloseTo(0.0002, 6);    // 0.0001 + 0.0001 + 0
    expect(stats.l1DataFeeEth).toBeCloseTo(0.0018, 6);  // 0.0009 + 0.0009 + 0
    expect(stats.revertCostEth).toBeCloseTo(0.001, 6);  // 0 + 0.001 + 0

    // Net P&L
    expect(stats.netProfitEth).toBeCloseTo(0.0021, 6);  // 0.019 - 0.0069 - 0.01

    // Win rate
    expect(stats.winRate).toBeCloseTo(1 / 3, 6);

    // Timestamps
    expect(stats.firstTradeTimestamp).toBe(1000);
    expect(stats.lastTradeTimestamp).toBe(3000);
  });

  it("should return last N trades in reverse chronological order", () => {
    const store = new TradeStore(TEST_FILE);

    const trades: TradeOutcome[] = [
      { txHash: "0x1", timestamp: 1000, blockNumber: 100, path: "A", inputAmount: 1, grossProfit: 0.01, gasCost: 0.0001, l1DataFee: 0.0009, revertCost: 0, netProfit: 0.009, status: "success" },
      { txHash: "0x2", timestamp: 2000, blockNumber: 101, path: "B", inputAmount: 1, grossProfit: 0.01, gasCost: 0.0001, l1DataFee: 0.0009, revertCost: 0, netProfit: 0.009, status: "success" },
      { txHash: "0x3", timestamp: 3000, blockNumber: 102, path: "C", inputAmount: 1, grossProfit: 0.01, gasCost: 0.0001, l1DataFee: 0.0009, revertCost: 0, netProfit: 0.009, status: "success" },
    ];

    for (const trade of trades) {
      store.append(trade);
    }

    const last2 = store.getLast(2);
    expect(last2).toHaveLength(2);
    expect(last2[0].txHash).toBe("0x3"); // Most recent first
    expect(last2[1].txHash).toBe("0x2");
  });

  it("should handle empty store gracefully", () => {
    const store = new TradeStore(TEST_FILE);

    const stats = store.getStats();
    expect(stats.totalTrades).toBe(0);
    expect(stats.winRate).toBe(0);
    expect(stats.netProfitEth).toBe(0);

    const last10 = store.getLast(10);
    expect(last10).toHaveLength(0);
  });

  it("should skip corrupted JSONL lines during load", () => {
    // Write a file with one valid line and one corrupted line
    fs.writeFileSync(
      TEST_FILE,
      JSON.stringify({ txHash: "0x123", timestamp: 1000, blockNumber: 100, path: "A", inputAmount: 1, grossProfit: 0.01, gasCost: 0.0001, l1DataFee: 0.0009, revertCost: 0, netProfit: 0.009, status: "success" }) + "\n" +
      "{ CORRUPTED JSON HERE\n",
      "utf-8"
    );

    const store = new TradeStore(TEST_FILE);

    // Should load the valid line, skip the corrupted line
    expect(store.getAll()).toHaveLength(1);
    expect(store.getAll()[0].txHash).toBe("0x123");
  });
});
```

**Coverage:**
1. Directory creation
2. Append + disk persistence
3. Restart recovery (load from disk)
4. Three-bucket stats computation
5. getLast() reverse chronological order
6. Empty store handling
7. Corrupted line resilience

Run with `pnpm test -- --run bot/__tests__/dashboard/trade-store.test.ts`
  </action>
  <verify>
`pnpm test -- --run bot/__tests__/dashboard/trade-store.test.ts` passes with all tests green (7+ test cases).
  </verify>
  <done>
Test file exists at `bot/__tests__/dashboard/trade-store.test.ts` with 7+ passing tests validating JSONL persistence, restart recovery, three-bucket accounting, and corrupted line resilience.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` — no type errors in dashboard module
2. `pnpm test -- --run bot/__tests__/dashboard/trade-store.test.ts` — all TradeStore tests pass
3. `pnpm test` — all existing tests still pass (no regressions)
4. Files exist: `bot/src/dashboard/types.ts`, `bot/src/dashboard/TradeStore.ts`, `bot/__tests__/dashboard/trade-store.test.ts`
5. TradeStore uses JSONL format (no better-sqlite3 imports)
6. Three-bucket accounting: `grossProfit`, `gasCost`, `l1DataFee`, `revertCost` are separate fields
</verification>

<success_criteria>
TradeStore module persists trade outcomes to `.data/trades.jsonl` using JSONL append-only format. Three-bucket accounting separates gross profit, gas costs (including L1 data fee), and revert costs. All tests pass, including restart recovery and corrupted line resilience.
</success_criteria>

<output>
After completion, create `.planning/phases/08-pnl-dashboard-operations/08-01-SUMMARY.md`
</output>
