---
phase: 11-dry-run-signal-quality-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/src/run-arb-mainnet.ts
  - bot/__tests__/integration/traderjoe-lb-integration.test.ts
autonomous: true
requirements: [DEX-06]

must_haves:
  truths:
    - "TJ LB fee display shows correct percentage (0.15% for binStep=15, not 0.00%)"
    - "Cost floor calculation for TJ LB uses binStep/10000 (not binStep/1000000)"
    - "Non-LB pool fee display is unchanged"
    - "All existing TS tests continue to pass"
  artifacts:
    - path: "bot/src/run-arb-mainnet.ts"
      provides: "Fixed fee display for TJ LB pools"
      contains: "traderjoe_lb"
  key_links:
    - from: "bot/src/run-arb-mainnet.ts"
      to: "bot/src/detector/types.ts"
      via: "ArbitrageOpportunity.path.steps[].feeTier interpretation"
      pattern: "traderjoe_lb.*feeTier"
---

<objective>
Fix TJ LB fee display bug found in the 6.5-hour dry-run. Two related display issues in the opportunity logging block of run-arb-mainnet.ts:

1. **Per-step fee display (line ~297):** `(step.feeTier / 10000).toFixed(2)` shows "0.00%" for TJ LB binStep=15. The division gives 0.0015 (correct value = 0.15%), but `.toFixed(2)` rounds to "0.00". For LB pools, feeTier is binStep in basis points (15 bps = 0.15%), not V3 hundredths-of-a-bip.

2. **Cost floor calculation (line ~303):** `s.feeTier !== undefined ? s.feeTier / 1_000_000 : 0.003` uses V3 scaling (hundredths-of-a-bip to decimal). For TJ LB, feeTier=15 should yield 0.0015 (15/10000), but the code gives 0.000015 (15/1000000). The cost floor for LB pools is underreported by 100x.

Purpose: Ensure operators see accurate fee information for TJ LB opportunities, matching the actual fee buffer logic in OpportunityDetector.getSwapFeeRate().
Output: Fixed display formatting in run-arb-mainnet.ts.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/src/run-arb-mainnet.ts
@bot/src/detector/OpportunityDetector.ts (reference for getSwapFeeRate logic)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix TJ LB fee display and cost floor formatting</name>
  <files>bot/src/run-arb-mainnet.ts</files>
  <action>
**1. Fix per-step fee display (around line 294-301):**

Replace the current fee rate formatting:
```typescript
const feeRate = step.feeTier !== undefined
  ? `${(step.feeTier / 10000).toFixed(2)}%`
  : "0.30% (V2)";
```

With DEX-aware formatting that handles LB's binStep differently from V3's hundredths-of-a-bip:
```typescript
let feeRate: string;
if (step.dex === "traderjoe_lb") {
  // LB: feeTier is binStep in basis points (15 = 0.15%)
  // Show with 50% buffer indicator matching getSwapFeeRate() logic
  const basePct = (step.feeTier ?? 0) / 100; // bps to percent
  feeRate = `${basePct.toFixed(2)}% (LB, +50% buffer)`;
} else if (step.feeTier !== undefined) {
  // V3: feeTier in hundredths of a bip (500 = 0.05%, 3000 = 0.3%)
  feeRate = `${(step.feeTier / 10000).toFixed(2)}%`;
} else {
  // V2: standard 0.3%
  feeRate = "0.30% (V2)";
}
```

**2. Fix cost floor calculation (around line 302-306):**

Replace the cost floor reduce:
```typescript
const combinedFee = opp.path.steps.reduce((sum, s) => {
  const rate = s.feeTier !== undefined ? s.feeTier / 1_000_000 : 0.003;
  return sum + rate;
}, 0);
```

With DEX-aware fee rate computation that mirrors `getSwapFeeRate()`:
```typescript
const combinedFee = opp.path.steps.reduce((sum, s) => {
  let rate: number;
  if (s.dex === "traderjoe_lb") {
    // LB: feeTier is binStep in bps, with 50% buffer
    rate = ((s.feeTier ?? 0) / 10_000) * 1.5;
  } else if (s.feeTier !== undefined) {
    // V3: feeTier in hundredths of a bip
    rate = s.feeTier / 1_000_000;
  } else {
    // V2: standard 0.3%
    rate = 0.003;
  }
  return sum + rate;
}, 0);
```

This exactly mirrors the logic in `OpportunityDetector.getSwapFeeRate()` so the display matches the actual computation.
  </action>
  <verify>
Run `pnpm exec tsc --noEmit` to verify no type errors.
Manually verify the fix by reading the modified lines and confirming:
- binStep=15 would display "0.15% (LB, +50% buffer)" instead of "0.00%"
- binStep=25 would display "0.25% (LB, +50% buffer)" instead of "0.00%"
- V3 feeTier=500 still displays "0.05%"
- V3 feeTier=3000 still displays "0.30%"
- Cost floor for LB path with binStep=15: (15/10000)*1.5 = 0.00225 â†’ "0.23%" (correct)
  </verify>
  <done>
TJ LB fee display shows correct percentage (e.g., "0.15% (LB, +50% buffer)" for binStep=15). Cost floor calculation for LB pools uses correct scaling (binStep/10000 with 1.5x buffer). V3 and V2 pool displays are unchanged. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add display format test for fee rendering</name>
  <files>bot/__tests__/integration/traderjoe-lb-integration.test.ts</files>
  <action>
Add a new test in the existing Trader Joe LB integration test file that validates the fee rate computation logic used in the display. Since the display code is in run-arb-mainnet.ts (an entry point, not easily unit-testable), extract and test the fee rate formatting logic:

Add a `describe("fee display formatting")` block with these tests:

```typescript
describe("fee display formatting", () => {
  it("should compute correct fee display for TJ LB binStep=15", () => {
    const binStep = 15;
    const basePct = binStep / 100; // bps to percent
    expect(basePct.toFixed(2)).toBe("0.15");
  });

  it("should compute correct fee display for TJ LB binStep=25", () => {
    const binStep = 25;
    const basePct = binStep / 100;
    expect(basePct.toFixed(2)).toBe("0.25");
  });

  it("should compute correct cost floor rate for TJ LB", () => {
    const binStep = 15;
    const rate = (binStep / 10_000) * 1.5; // with 50% buffer
    expect(rate).toBeCloseTo(0.00225, 6);
    // Display: (0.00225 * 100).toFixed(2) = "0.23%"
    expect((rate * 100).toFixed(2)).toBe("0.23");
  });

  it("should compute correct cost floor rate for V3 feeTier=500", () => {
    const feeTier = 500; // 0.05%
    const rate = feeTier / 1_000_000;
    expect(rate).toBeCloseTo(0.0005, 6);
  });

  it("should not affect V2 display (no feeTier)", () => {
    // V2 pools use default 0.3% = 0.003
    const rate = 0.003;
    expect((rate * 100).toFixed(2)).toBe("0.30");
  });
});
```

These tests validate the arithmetic used in the display formatting, ensuring the fix produces correct output for all DEX types.

Run: `pnpm test -- --run bot/__tests__/integration/traderjoe-lb-integration.test.ts`
  </action>
  <verify>
Run `pnpm test -- --run bot/__tests__/integration/traderjoe-lb-integration.test.ts` to verify new tests pass.
Then run `pnpm test -- --run` to verify full suite passes.
  </verify>
  <done>
5 new tests validate fee display arithmetic for TJ LB (binStep=15, binStep=25), cost floor computation with 50% buffer, V3 fee display, and V2 default fee display. All existing tests pass. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes (no type errors)
2. `pnpm test -- --run bot/__tests__/integration/traderjoe-lb-integration.test.ts` passes
3. `pnpm test -- --run` passes (full TS suite)
4. Manual review: binStep=15 shows "0.15%" not "0.00%"
</verification>

<success_criteria>
1. TJ LB fee display shows correct percentage (0.15% for binStep=15)
2. Cost floor calculation for TJ LB uses correct scaling with 50% buffer
3. V3 and V2 fee displays are unchanged
4. All TS tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-dry-run-signal-quality-fixes/11-02-SUMMARY.md`
</output>
