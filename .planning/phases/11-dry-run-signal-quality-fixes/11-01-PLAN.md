---
phase: 11-dry-run-signal-quality-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/src/detector/OpportunityDetector.ts
  - bot/src/detector/types.ts
  - bot/__tests__/detector/OpportunityDetector.test.ts
autonomous: true
requirements: [SIZE-02, SIZE-03]

must_haves:
  truths:
    - "TJ LB opportunities use at most 5 ETH input (not 500 ETH) when no reserve data is available"
    - "V3 pools with liquidity data produce virtualReserveIn on both buy and sell steps"
    - "computeReserveCap returns a conservative cap when any step lacks reserve data (not just the minimum of available ones)"
    - "All existing TS tests continue to pass"
  artifacts:
    - path: "bot/src/detector/OpportunityDetector.ts"
      provides: "Per-DEX max input cap, fixed computeReserveCap"
      contains: "maxInputByDex"
    - path: "bot/__tests__/detector/OpportunityDetector.test.ts"
      provides: "Tests for TJ LB input cap and V3 reserve propagation"
  key_links:
    - from: "bot/src/detector/OpportunityDetector.ts"
      to: "bot/src/monitor/types.ts"
      via: "PriceSnapshot reserve data check"
      pattern: "traderjoe_lb.*maxInput"
---

<objective>
Fix two critical signal quality issues from the 6.5-hour dry-run:

1. **TJ LB input cap (CRITICAL):** TJ LB pools have no reserve/liquidity data in PriceSnapshot (they use bin-based liquidity, not V2 reserves or V3 L+sqrtPriceX96). Without reserve data, the optimizer falls back to defaultInputAmount but the slippage model also has no depth info, producing fantasy numbers (500 ETH with 0.004 ETH slippage). Fix: add a per-DEX maximum input cap to OpportunityDetector that caps TJ LB pools to 5 ETH.

2. **V3 reserve cap failure (MEDIUM):** When a path has one pool WITH reserve data (e.g., deep UniV3 WETH/USDC) and one WITHOUT (e.g., thin Camelot V3 GMX/WETH where liquidity() call fails silently), `computeReserveCap()` only considers the pool WITH data, returning a huge cap (30% of 10,000 WETH = 3,000 ETH). The thin pool without data is ignored. Fix: when any step lacks virtualReserveIn, apply a conservative default cap (5 ETH) as the floor for that step's contribution to the minimum.

Purpose: Prevent false-positive opportunities with absurd input sizes that would be massive losses in reality.
Output: Modified OpportunityDetector with per-DEX caps and fixed reserve cap logic, with tests.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/src/detector/OpportunityDetector.ts
@bot/src/detector/types.ts
@bot/src/monitor/types.ts
@bot/src/optimizer/InputOptimizer.ts
@bot/__tests__/detector/OpportunityDetector.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add per-DEX max input cap and fix computeReserveCap</name>
  <files>
    bot/src/detector/OpportunityDetector.ts
    bot/src/detector/types.ts
  </files>
  <action>
**1. Add `maxInputByDex` config to OpportunityDetectorConfig (types.ts):**

Add an optional field to `OpportunityDetectorConfig`:
```typescript
/** Per-DEX maximum input amount overrides. Used to cap pools that lack reserve data
 *  (e.g., Trader Joe LB uses bin-based liquidity with no reserve/depth info).
 *  Key: DEXProtocol string, Value: max input in base token units. */
maxInputByDex?: Partial<Record<DEXProtocol, number>>;
```

Import `DEXProtocol` from `../monitor/types.js` if not already imported.

**2. Wire maxInputByDex into OpportunityDetector constructor (OpportunityDetector.ts):**

In the constructor, store the config with a sensible default for traderjoe_lb:
```typescript
this.maxInputByDex = {
  traderjoe_lb: 5, // Conservative: LB bins typically hold 2-20 ETH depth
  ...config.maxInputByDex,
};
```

Add `private readonly maxInputByDex: Partial<Record<DEXProtocol, number>>;` as a class field.

**3. Apply per-DEX cap in analyzeDelta and analyzeDeltaAsync:**

After the optimization/fallback block that determines `inputAmount`, add cap logic:

```typescript
// Apply per-DEX max input cap (for pools without reserve data like TJ LB)
const dexCap = this.getDexInputCap(path);
if (dexCap !== undefined && inputAmount > dexCap) {
  inputAmount = dexCap;
}
```

Add a private method `getDexInputCap(path: SwapPath): number | undefined` that:
- Iterates path.steps and collects `this.maxInputByDex[step.dex]` for each step
- Returns the minimum cap found (undefined if no DEX in the path has a cap)

This method must be added to BOTH `analyzeDelta()` and `analyzeDeltaAsync()`.

**4. Fix computeReserveCap to handle missing reserve data conservatively:**

Currently `computeReserveCap()` only considers steps WITH virtualReserveIn > 0 and ignores steps without it. When a step lacks data (e.g., thin V3 pool where liquidity() failed, or LB pool), that unknown depth should be treated as a constraint, not ignored.

Modify `computeReserveCap()`:
```typescript
private computeReserveCap(path: SwapPath): number | undefined {
  let minReserve: number | undefined;
  let hasUnknownStep = false;

  for (const step of path.steps) {
    if (step.virtualReserveIn !== undefined && step.virtualReserveIn > 0) {
      if (minReserve === undefined || step.virtualReserveIn < minReserve) {
        minReserve = step.virtualReserveIn;
      }
    } else {
      hasUnknownStep = true;
    }
  }

  // If any step lacks reserve data, apply per-DEX cap as conservative bound
  if (hasUnknownStep) {
    const dexCap = this.getDexInputCap(path);
    if (dexCap !== undefined) {
      if (minReserve === undefined || dexCap < minReserve * 0.3) {
        return dexCap;
      }
    }
    // If no per-DEX cap and no reserve data at all, return undefined (fallback to default)
    if (minReserve === undefined) return undefined;
  }

  // Cap at 30% of the shallowest pool's depth
  return minReserve! * 0.3;
}
```

This ensures that when one leg of the path has no depth info (unknown step), the per-DEX cap provides a conservative upper bound.
  </action>
  <verify>
Run `pnpm exec tsc --noEmit` to verify no type errors. The type extension and new method should compile cleanly.
  </verify>
  <done>
OpportunityDetector has a maxInputByDex config with traderjoe_lb defaulting to 5 ETH. Both analyzeDelta and analyzeDeltaAsync apply the per-DEX cap after optimization. computeReserveCap handles steps without reserve data conservatively. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for TJ LB input cap and reserve cap fix</name>
  <files>
    bot/__tests__/detector/OpportunityDetector.test.ts
  </files>
  <action>
Add a new `describe` block in OpportunityDetector.test.ts for signal quality fixes:

```typescript
describe("signal quality: per-DEX input cap", () => {
  // Test 1: TJ LB opportunities are capped at maxInputByDex.traderjoe_lb
  // Create a detector with traderjoe_lb cap = 5
  // Create a PriceDelta with one TJ LB pool (no reserves, no liquidity)
  // and one UniV3 pool (with reserves)
  // Verify: opportunity.inputAmount <= 5

  // Test 2: Non-LB pools are NOT capped when they have reserve data
  // Create a PriceDelta with two UniV3 pools (both with liquidity)
  // Verify: inputAmount can be > 5 (optimizer finds optimal size)

  // Test 3: Custom maxInputByDex overrides default
  // Create detector with maxInputByDex: { traderjoe_lb: 2 }
  // Verify: opportunity.inputAmount <= 2
});

describe("signal quality: computeReserveCap with unknown steps", () => {
  // Test 4: When path has one step with reserves and one without,
  // computeReserveCap should return conservative cap (per-DEX cap)
  // instead of just 30% of the known step's reserve.
  // Create path: buyStep (UniV3, 10000 WETH reserve) + sellStep (TJ LB, no reserve)
  // Without fix: reserveCap = 10000 * 0.3 = 3000 (absurd)
  // With fix: reserveCap = 5 (TJ LB cap)

  // Test 5: When both steps have reserve data, behavior is unchanged
  // Create path: buyStep (V2, 500 WETH) + sellStep (V3, 200 WETH)
  // reserveCap = 200 * 0.3 = 60 (unchanged from before)
});
```

Use existing test patterns from the file:
- Mock PriceSnapshot with appropriate fields (reserves for V2, liquidity+sqrtPriceX96 for V3, activeId for LB)
- Use `analyzeDelta()` to test the full flow
- Assert on `opportunity.inputAmount` for cap tests
- Use the same PoolConfig/PriceDelta construction patterns as existing tests

Run: `pnpm test -- --run bot/__tests__/detector/OpportunityDetector.test.ts`
  </action>
  <verify>
Run `pnpm test -- --run bot/__tests__/detector/OpportunityDetector.test.ts` and verify all tests pass (existing + new).
Then run `pnpm test -- --run` to verify no regressions across the full test suite.
  </verify>
  <done>
At least 5 new test cases covering: TJ LB input cap enforcement, non-LB pools unaffected, custom cap override, mixed reserve/no-reserve path cap, and unchanged behavior when both steps have reserves. All existing tests continue to pass. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes (no type errors)
2. `pnpm test -- --run bot/__tests__/detector/OpportunityDetector.test.ts` passes (all detector tests including new ones)
3. `pnpm test -- --run` passes (full TS suite, no regressions)
4. `forge test` passes (Solidity tests unaffected)
</verification>

<success_criteria>
1. TJ LB opportunities have inputAmount capped at 5 ETH (not 500 ETH)
2. Paths with one unknown-depth step get conservative cap from per-DEX config
3. V3 pools with reserve data still use optimized sizing (no regression)
4. All 554+ TS tests and 342 Solidity tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-dry-run-signal-quality-fixes/11-01-SUMMARY.md`
</output>
