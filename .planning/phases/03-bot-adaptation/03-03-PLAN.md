---
phase: 03-bot-adaptation
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - bot/src/detector/OpportunityDetector.ts
  - bot/src/reporting.ts
  - bot/src/run-arb-sepolia.ts
  - bot/src/__tests__/gas/ArbitrumGasEstimator.test.ts
  - bot/src/__tests__/config/chain-config.test.ts
autonomous: true

must_haves:
  truths:
    - "OpportunityDetector accepts optional gasEstimatorFn and uses it to add l1DataFee to CostEstimate"
    - "Dry-run opportunity report shows L1 data fee as separate line item when present"
    - "run-arb-sepolia.ts injects Arbitrum gas estimator into the detector"
    - "Unit tests verify ArbitrumGasEstimator returns correct gas component structure"
    - "Unit tests verify chain config loads correct Arbitrum Sepolia addresses"
  artifacts:
    - path: "bot/src/detector/OpportunityDetector.ts"
      provides: "OpportunityDetector with pluggable gas estimator"
      contains: "gasEstimatorFn"
    - path: "bot/src/reporting.ts"
      provides: "Opportunity report with L1 data fee line"
      contains: "l1DataFee"
    - path: "bot/src/__tests__/gas/ArbitrumGasEstimator.test.ts"
      provides: "Unit tests for ArbitrumGasEstimator"
      contains: "estimateArbitrumGas"
    - path: "bot/src/__tests__/config/chain-config.test.ts"
      provides: "Unit tests for Arbitrum Sepolia chain config"
      contains: "421614"
  key_links:
    - from: "bot/src/run-arb-sepolia.ts"
      to: "bot/src/gas/ArbitrumGasEstimator.ts"
      via: "import and inject estimator function"
      pattern: "estimateArbitrumGas"
    - from: "bot/src/detector/OpportunityDetector.ts"
      to: "bot/src/detector/types.ts"
      via: "CostEstimate.l1DataFee populated by gasEstimatorFn"
      pattern: "l1DataFee"
    - from: "bot/src/reporting.ts"
      to: "bot/src/detector/types.ts"
      via: "reads CostEstimate.l1DataFee for display"
      pattern: "l1DataFee"
---

<objective>
Integrate the Arbitrum gas estimator into the detector pipeline and dry-run reporting. Add the `gasEstimatorFn` to OpportunityDetector, update reporting to show L1 data fees, wire the estimator into `run-arb-sepolia.ts`, and create unit tests for the gas estimator and chain config.

Purpose: This completes BOT-04 (Arbitrum-accurate gas estimation) and BOT-05 (dry-run reporting with L1 costs). The detector now shows real total costs instead of misleading L2-only estimates.

Output: Integrated gas estimation pipeline, updated reports, comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-bot-adaptation/03-RESEARCH.md
@.planning/phases/03-bot-adaptation/03-01-SUMMARY.md
@.planning/phases/03-bot-adaptation/03-02-SUMMARY.md
@bot/src/detector/OpportunityDetector.ts
@bot/src/detector/types.ts
@bot/src/reporting.ts
@bot/src/run-arb-sepolia.ts
@bot/src/gas/ArbitrumGasEstimator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add gasEstimatorFn to OpportunityDetector and update reporting</name>
  <files>
    bot/src/detector/OpportunityDetector.ts
    bot/src/detector/types.ts
    bot/src/reporting.ts
    bot/src/run-arb-sepolia.ts
  </files>
  <action>
    **In `bot/src/detector/types.ts`:**

    1. Add an optional `gasEstimatorFn` field to `OpportunityDetectorConfig`:
       ```typescript
       /** Optional async gas estimator. When provided, overrides the simple gasPriceGwei formula.
        *  Returns the total gas cost in ETH including L1 data fees (for L2 chains like Arbitrum).
        *  The function receives the number of swaps and should return { gasCost: number; l1DataFee?: number } */
       gasEstimatorFn?: (numSwaps: number) => Promise<{ gasCost: number; l1DataFee?: number }>;
       ```

    **In `bot/src/detector/OpportunityDetector.ts`:**

    2. Store `gasEstimatorFn` in the resolved config if provided.

    3. The current `estimateCosts()` method is synchronous. Since the gas estimator is async (calls NodeInterface RPC), change the approach:
       - Keep `estimateCosts()` synchronous for the standard L2-only path.
       - Add a new method `estimateCostsWithL1(path, inputAmount): Promise<CostEstimate>` that calls `gasEstimatorFn` when available, falling back to `estimateCosts()` if not.
       - In `analyzeDelta()`, check if `gasEstimatorFn` is set. If yes, call `estimateCostsWithL1()` instead. Since `analyzeDelta` is currently sync, it needs to become async (or use a separate async handler). **Approach:** Make `handleDelta` call an async `analyzeDeltaAsync` that awaits the gas estimate, then emits. Keep the existing sync `analyzeDelta` for backward compatibility (it still works without gasEstimatorFn).

    4. Specific implementation:
       - Add `private async analyzeDeltaAsync(delta: PriceDelta): Promise<ArbitrageOpportunity | null>` method.
       - This mirrors `analyzeDelta` but calls `await this.estimateCostsWithL1()` for the gas estimate.
       - When `l1DataFee` is returned, add it to the `CostEstimate` and include it in `totalCost`.
       - Update `handleDelta` to call `analyzeDeltaAsync` when `gasEstimatorFn` is present, `analyzeDelta` otherwise.
       - The `async` handler should catch errors and emit them via `this.emit("error", ...)`.

    5. Do NOT break existing sync behavior. When `gasEstimatorFn` is undefined, `analyzeDelta` runs exactly as before (synchronous, no L1 fees).

    **In `bot/src/reporting.ts`:**

    6. In `formatOpportunityReport()`, after the `Gas cost:` line, add a conditional L1 data fee line:
       ```typescript
       if (costs.l1DataFee !== undefined && costs.l1DataFee > 0) {
         lines.push(`    L1 data fee:    ${costs.l1DataFee.toFixed(6)}`);
       }
       ```
       This goes between `Gas cost:` and `Slippage:` lines.

    **In `bot/src/run-arb-sepolia.ts`:**

    7. Import `estimateArbitrumGas, gasComponentsToEth` from `./gas/index.js`.

    8. After constructing the bot, create a gas estimator function:
       ```typescript
       const arbGasEstimator = async (numSwaps: number) => {
         // Build approximate calldata for a swap transaction
         // Each swap step ~= 256 bytes calldata (conservative estimate)
         const estimatedCalldataSize = 4 + 32 * 8 * numSwaps; // function selector + args
         const dummyData = "0x" + "00".repeat(estimatedCalldataSize);
         const flashloanExecutor = chain.protocols?.aaveV3Pool ?? "0x0000000000000000000000000000000000000001";

         try {
           const provider = new JsonRpcProvider(chain.rpcUrl);
           const components = await estimateArbitrumGas(provider, flashloanExecutor, dummyData);
           const ethCosts = gasComponentsToEth(components);
           return { gasCost: ethCosts.l2CostEth, l1DataFee: ethCosts.l1CostEth };
         } catch (err) {
           // Fallback: use simple estimation if NodeInterface call fails (e.g., on local fork)
           console.warn(`[GAS] NodeInterface call failed, using L2-only estimate: ${err instanceof Error ? err.message : err}`);
           return { gasCost: 0, l1DataFee: undefined };
         }
       };
       ```

    9. Pass `gasEstimatorFn: arbGasEstimator` in the detector config when constructing FlashloanBot:
       ```typescript
       detector: { ...chain.detector, gasEstimatorFn: arbGasEstimator },
       ```

       NOTE: This requires that `DetectorConfig` in `bot/src/config/types.ts` also allows `gasEstimatorFn`. If `DetectorConfig` is used in the `BotConfig.detector` field and it doesn't include `gasEstimatorFn`, the entry point should construct the `OpportunityDetector` separately and pass the estimator directly. Check the type chain:
       - `BotConfig.detector` is `DetectorConfig` (from `config/types.ts`)
       - `OpportunityDetector` constructor takes `OpportunityDetectorConfig` (from `detector/types.ts`)
       - These are different types. The FlashloanBot constructor maps `DetectorConfig` -> `OpportunityDetectorConfig`.

       **Resolution:** The entry point should NOT pass `gasEstimatorFn` through `BotConfig`. Instead, after constructing the bot, set the gas estimator on the detector directly:
       ```typescript
       // After bot construction, inject gas estimator
       // This requires adding a setter or constructor option on OpportunityDetector
       ```
       The cleanest approach: add `setGasEstimator(fn)` method to `OpportunityDetector`, or pass it via a public property after construction. The entry point calls:
       ```typescript
       bot.detector.setGasEstimator(arbGasEstimator);
       ```

    10. Update the opportunity log in `run-arb-sepolia.ts` to show L1 data fee when present:
        ```typescript
        bot.detector.on("opportunityFound", (opp: ArbitrageOpportunity) => {
          console.log(`[OPPORTUNITY] ${opp.path.label}`);
          console.log(`  Gross: ${opp.grossProfit.toFixed(8)} ETH`);
          console.log(`  Gas (L2): ${opp.costs.gasCost.toFixed(8)} ETH`);
          if (opp.costs.l1DataFee !== undefined) {
            console.log(`  L1 data fee: ${opp.costs.l1DataFee.toFixed(8)} ETH`);
          }
          console.log(`  Total cost: ${opp.costs.totalCost.toFixed(8)} ETH`);
          console.log(`  Net: ${opp.netProfit.toFixed(8)} ETH`);
          console.log(`  [REPORT-ONLY] No transaction sent`);
        });
        ```
  </action>
  <verify>
    1. `pnpm test` passes — all existing tests still pass.
    2. TypeScript compiles without errors.
    3. `OpportunityDetector` has `setGasEstimator` method (or equivalent).
    4. `formatOpportunityReport` shows L1 data fee line when `costs.l1DataFee` is set.
    5. `run-arb-sepolia.ts` imports and injects the Arbitrum gas estimator.
  </verify>
  <done>
    OpportunityDetector accepts gasEstimatorFn and produces CostEstimate with l1DataFee populated. Reporting shows L1 data fee as separate line item. run-arb-sepolia.ts injects Arbitrum gas estimator. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for ArbitrumGasEstimator and chain config</name>
  <files>
    bot/src/__tests__/gas/ArbitrumGasEstimator.test.ts
    bot/src/__tests__/config/chain-config.test.ts
  </files>
  <action>
    **Create `bot/src/__tests__/gas/ArbitrumGasEstimator.test.ts`:**

    Test the ArbitrumGasEstimator module. Since we can't call a real Arbitrum node in unit tests, mock the ethers.js `Contract`:

    1. Test `gasComponentsToEth` with known values:
       - Input: `{ totalGas: 500000n, l1Gas: 475000n, l2Gas: 25000n, baseFee: 100000000n (0.1 gwei), l1BaseFeeEstimate: 10000000000n (10 gwei), totalCostWei: 50000000000000n }`
       - Expected: `totalCostEth ≈ 0.00005`, `l1CostEth > l2CostEth`

    2. Test that `estimateArbitrumGas` calls the correct contract method:
       - Mock `Contract` to return a fake result from `gasEstimateComponents`.
       - Verify the function returns `ArbitrumGasComponents` with correct structure.
       - Verify `l2Gas = totalGas - l1Gas`.

    3. Test edge case: `gasEstimateComponents` returns zero L1 gas (testnet scenario):
       - `l1Gas: 0n` → `l2Gas === totalGas`.

    4. Test `NODE_INTERFACE_ADDRESS` is `0x00000000000000000000000000000000000000C8`.

    Use Vitest (`describe`, `it`, `expect`). Mock ethers.js `Contract` using `vi.mock` or manual mock.

    **Create `bot/src/__tests__/config/chain-config.test.ts`:**

    Test the chain config system for Arbitrum Sepolia:

    5. Test `loadChainConfig(421614)` returns config with:
       - `chainId === 421614`
       - `chainName === "Arbitrum Sepolia"`
       - `tokens.WETH === "0x980B62Da83eFf3D4576C647993b0c1D7faf17c73"` (not zero address)
       - `dexes.uniswapV3.factory === "0x248AB79Bbb9bC29bB72f7Cd42F17e054Fc40188e"` (not Ethereum mainnet address)
       - `protocols.aaveV3Pool === "0x794a61358D6845594F94dc1DB02A252b5b4814aD"`
       - `monitor.pollIntervalMs === 1000` (not 12000)
       - `mev.mode === "none"`

    6. Test `loadChainConfig(42161)` returns Arbitrum mainnet config (sanity check).

    7. Test `loadChainConfig(99999)` throws with unsupported chain error.

    8. Test that `ARBITRUM_SEPOLIA_CONFIG.pools` is an array (may be empty, that's OK for Phase 3).

    Use Vitest. These are pure unit tests — no network calls, no mocking needed (just import and check values).
  </action>
  <verify>
    1. `pnpm test` passes — all tests including the new ones.
    2. New test files exist at the expected paths.
    3. Run `pnpm test -- --run bot/src/__tests__/gas/ArbitrumGasEstimator.test.ts` — all pass.
    4. Run `pnpm test -- --run bot/src/__tests__/config/chain-config.test.ts` — all pass.
  </verify>
  <done>
    Unit tests verify ArbitrumGasEstimator correctly calls NodeInterface and returns structured gas components. Unit tests verify Arbitrum Sepolia chain config has correct factory, WETH, and protocol addresses. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test` — all TypeScript tests pass (existing 423 + new gas + config tests)
2. `forge test` — all 312 Solidity tests pass
3. `OpportunityDetector` accepts and uses `gasEstimatorFn` when provided
4. `formatOpportunityReport` shows L1 data fee line when `CostEstimate.l1DataFee` is present
5. `run-arb-sepolia.ts` creates and injects Arbitrum gas estimator
6. New test files exist and pass
</verification>

<success_criteria>
- OpportunityDetector uses gasEstimatorFn (async) for Arbitrum, falls back to sync formula for other chains
- CostEstimate.l1DataFee populated with Arbitrum L1 data cost
- Dry-run report shows: Gas (L2), L1 data fee, Total cost as separate lines
- run-arb-sepolia.ts wires everything together: loadChainConfig → FlashloanBot → ArbitrumGasEstimator
- Unit tests cover gas estimator (mocked provider) and chain config (address verification)
- All existing + new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-bot-adaptation/03-03-SUMMARY.md`
</output>
