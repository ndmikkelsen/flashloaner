---
phase: 09-ramses-v2-adapter
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - bot/src/config/chains/pools/arbitrum-mainnet.ts
  - bot/src/monitor/PriceMonitor.ts
  - bot/src/detector/OpportunityDetector.ts
  - bot/__tests__/monitor/ramses-price.test.ts
autonomous: true
requirements:
  - DEX-01
  - DEX-03

must_haves:
  truths:
    - "Bot monitors 2+ Ramses V3 CL pools via slot0() price reading"
    - "Bot detects cross-DEX spreads between Ramses and existing pools (e.g., Ramses vs Uniswap V3 WETH/USDC)"
    - "All Ramses opportunities require 2x the standard minimum profit threshold (0.02 instead of 0.01)"
    - "PriceMonitor.isV3Pool() correctly identifies 'ramses_v3' as a V3 pool type"
  artifacts:
    - path: "bot/src/config/chains/pools/arbitrum-mainnet.ts"
      provides: "Ramses V3 pool entries with addresses, fee tiers, token ordering"
      contains: "ramses_v3"
    - path: "bot/src/monitor/PriceMonitor.ts"
      provides: "Updated isV3Pool() to include 'ramses_v3'"
      contains: 'ramses_v3'
    - path: "bot/src/detector/OpportunityDetector.ts"
      provides: "2x profit threshold for Ramses opportunities"
      contains: "ramses"
    - path: "bot/__tests__/monitor/ramses-price.test.ts"
      provides: "Tests validating Ramses V3 price reading with slot0()"
      min_lines: 50
  key_links:
    - from: "bot/src/config/chains/pools/arbitrum-mainnet.ts"
      to: "bot/src/config/chains/arbitrum.ts"
      via: "ARBITRUM_MAINNET_POOLS export"
      pattern: "ARBITRUM_MAINNET_POOLS"
    - from: "bot/src/monitor/PriceMonitor.ts"
      to: "bot/src/config/chains/pools/arbitrum-mainnet.ts"
      via: "polls Ramses pools via slot0()"
      pattern: "isV3Pool.*ramses_v3"
    - from: "bot/src/detector/OpportunityDetector.ts"
      to: "bot/src/monitor/types.ts"
      via: "reads DEX type from PriceDelta"
      pattern: "delta.*buyPool.*dex.*ramses"
---

<objective>
Integrate Ramses V3 pools into bot monitoring with cross-DEX arbitrage detection and 2x profit threshold to mitigate fee manipulation risk.

Purpose: Ramses V3 CL pools use the same slot0() interface as Uniswap V3, so price monitoring is a 5-line addition to PriceMonitor.isV3Pool(). The critical risk is documented insider fee manipulation (zero-fee arbitrage), so ALL Ramses opportunities require 2x the standard profit threshold (0.02 instead of 0.01). This plan wires pool config, price reading, and profit filtering.

Output: Bot monitors Ramses V3 pools, detects cross-DEX spreads, and applies 2x profit threshold automatically.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ramses-v2-adapter/09-01-PLAN.md

@bot/src/config/chains/pools/arbitrum-mainnet.ts
@bot/src/monitor/PriceMonitor.ts
@bot/src/detector/OpportunityDetector.ts
@bot/src/monitor/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Ramses V3 pool entries to Arbitrum pool config</name>
  <files>bot/src/config/chains/pools/arbitrum-mainnet.ts</files>
  <action>
Add 2-3 Ramses V3 CL pool entries to `bot/src/config/chains/pools/arbitrum-mainnet.ts` for high-liquidity token pairs.

**Pool discovery strategy:**
Use Ramses V3 Factory (`0xd0019e86edB35E1fedaaB03aED5c3c60f115d28b`) to find pool addresses:

```bash
# WETH/USDC.e 0.05%
cast call 0xd0019e86edB35E1fedaaB03aED5c3c60f115d28b \
  "getPool(address,address,uint24)(address)" \
  0x82af49447d8a07e3bd95bd0d56f35241523fbab1 \
  0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8 \
  500 --rpc-url $ARBITRUM_RPC_URL

# WETH/USDT 0.05%
cast call 0xd0019e86edB35E1fedaaB03aED5c3c60f115d28b \
  "getPool(address,address,uint24)(address)" \
  0x82af49447d8a07e3bd95bd0d56f35241523fbab1 \
  0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9 \
  500 --rpc-url $ARBITRUM_RPC_URL

# ARB/WETH 0.05%
cast call 0xd0019e86edB35E1fedaaB03aED5c3c60f115d28b \
  "getPool(address,address,uint24)(address)" \
  0x912ce59144191c1204e64559fe8253a0e49e6548 \
  0x82af49447d8a07e3bd95bd0d56f35241523fbab1 \
  500 --rpc-url $ARBITRUM_RPC_URL
```

**For each discovered pool, verify:**
1. **Token ordering** (lower hex address = token0):
   ```bash
   cast call <POOL_ADDRESS> "token0()(address)" --rpc-url $ARBITRUM_RPC_URL
   cast call <POOL_ADDRESS> "token1()(address)" --rpc-url $ARBITRUM_RPC_URL
   ```

2. **Non-zero liquidity** (skip pools with L=0):
   ```bash
   cast call <POOL_ADDRESS> "liquidity()(uint128)" --rpc-url $ARBITRUM_RPC_URL
   ```

**Pool entry format (add to appropriate token pair section):**
```typescript
{
  label: "WETH/USDC Ramses V3 (0.05%)",
  dex: "ramses_v3",
  poolAddress: "<discovered address>",
  token0: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1", // WETH
  token1: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8", // USDC.e
  decimals0: 18,
  decimals1: 6,
  feeTier: 500,
},
```

**Placement:** Insert Ramses pools in the relevant token pair sections (WETH/USDC, WETH/USDT, ARB/WETH) to create cross-DEX pairing opportunities. Place after existing Uniswap V3 pools for that pair.

**Fallback if cast unavailable:** Use known Ramses V3 pool addresses from Ramses Analytics or Arbiscan. Verify token ordering matches on-chain data.

**Recommended pools (prioritize high-liquidity pairs):**
1. WETH/USDC.e 0.05% (cross-DEX with UniV3 0.05% and 0.3%)
2. WETH/USDT 0.05% (cross-DEX with UniV3 0.05% and 0.3%)
3. ARB/WETH 0.05% (cross-DEX with UniV3 0.05% and 0.3%)

**What to avoid:**
- Pools with zero liquidity (L=0)
- Exotic token pairs with thin liquidity
- Ramses V2 AMM pools (this phase is V3 CL only)
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes (no type errors)
2. `grep -c '"ramses_v3"' bot/src/config/chains/pools/arbitrum-mainnet.ts` returns >=2 (2+ Ramses pools added)
3. All pool addresses are valid 42-character hex strings
4. All token0 addresses are lexicographically lower than token1 addresses
5. Pool config export compiles without errors
  </verify>
  <done>
Arbitrum pool config includes 2+ Ramses V3 CL pool entries with verified token ordering and non-zero liquidity. Pools create cross-DEX pairing opportunities with existing Uniswap V3 pools.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update PriceMonitor.isV3Pool() to recognize 'ramses_v3'</name>
  <files>bot/src/monitor/PriceMonitor.ts</files>
  <action>
Update the `isV3Pool()` method in `bot/src/monitor/PriceMonitor.ts` to include `"ramses_v3"` in the V3 pool type check.

**Current implementation (line ~319):**
```typescript
private isV3Pool(pool: PoolConfig): boolean {
  return pool.dex === "uniswap_v3" || pool.dex === "sushiswap_v3" || pool.dex === "camelot_v3";
}
```

**Updated implementation:**
```typescript
private isV3Pool(pool: PoolConfig): boolean {
  return pool.dex === "uniswap_v3" || pool.dex === "sushiswap_v3" || pool.dex === "camelot_v3" || pool.dex === "ramses_v3";
}
```

**Why this is sufficient:** Ramses V3 uses the same `slot0()` interface as Uniswap V3. The existing price reading logic in `fetchV3Price()` and `decodePriceFromResult()` works without modification because:
1. `getCallDataForPool()` already handles "unknown" V3 protocols by falling through to Uniswap V3 slot0() encoding
2. `decodePriceFromResult()` uses the same slot0() decoding for all V3 pools
3. Liquidity fetching via `fetchLiquidity()` uses the standard V3 `liquidity()` function

**What NOT to change:**
- Do NOT add "ramses_v3" to `getCallDataForPool()` switch cases (fallthrough is correct)
- Do NOT add "ramses_v3" to `decodePriceFromResult()` switch cases (reuses Uniswap V3 path)
- Do NOT modify price calculation logic (same sqrtPriceX96 formula)

**Verification point:** After this change, Ramses V3 pools will be included in the liquidity fetch batch and use slot0() for price reading.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes
2. `grep -c 'ramses_v3' bot/src/monitor/PriceMonitor.ts` returns 1 (isV3Pool updated)
3. `pnpm test` passes (existing tests unbroken)
  </verify>
  <done>
PriceMonitor.isV3Pool() includes "ramses_v3" in the V3 pool type check. Ramses pools now use slot0() price reading and liquidity fetching.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add 2x profit threshold for Ramses opportunities in OpportunityDetector</name>
  <files>bot/src/detector/OpportunityDetector.ts</files>
  <action>
Update `OpportunityDetector.analyzeDelta()` and `analyzeDeltaAsync()` to apply a 2x profit threshold multiplier when either pool in the price delta is from Ramses.

**Risk rationale:** Ramses V3 has documented insider fee manipulation where privileged accounts can set zero fees and execute risk-free arbitrage. To prevent false positives from manipulated spreads, require 2x the standard minimum profit threshold for any opportunity involving Ramses.

**Implementation approach:**

1. **Create helper method to check if opportunity involves Ramses:**
```typescript
/**
 * Check if a price delta involves a Ramses pool (either buy or sell side).
 * Returns true if either pool.dex is "ramses_v3".
 */
private involvesRamses(delta: PriceDelta): boolean {
  return delta.buyPool.pool.dex === "ramses_v3" || delta.sellPool.pool.dex === "ramses_v3";
}
```

2. **Update analyzeDelta() to apply threshold multiplier (line ~112):**

**Current code:**
```typescript
if (netProfit < this.config.minProfitThreshold) {
  this.emit(
    "opportunityRejected",
    `Net profit ${netProfit.toFixed(6)} below threshold ${this.config.minProfitThreshold}`,
    delta,
  );
  return null;
}
```

**Updated code:**
```typescript
// Apply 2x threshold for Ramses opportunities due to fee manipulation risk
const effectiveThreshold = this.involvesRamses(delta)
  ? this.config.minProfitThreshold * 2
  : this.config.minProfitThreshold;

if (netProfit < effectiveThreshold) {
  this.emit(
    "opportunityRejected",
    `Net profit ${netProfit.toFixed(6)} below threshold ${effectiveThreshold.toFixed(6)}${this.involvesRamses(delta) ? ' (2x for Ramses)' : ''}`,
    delta,
  );
  return null;
}
```

3. **Apply same change to analyzeDeltaAsync() (line ~205):** Duplicate the threshold logic in the async path.

**Why 2x:** With standard threshold 0.01 (1%), Ramses requires 0.02 (2%). This accounts for the risk that the spread might disappear when a privileged account reverts fee to normal, causing the trade to fail. The 2x buffer ensures we only execute Ramses trades with genuinely large, persistent spreads.

**What NOT to do:**
- Do NOT reject all Ramses opportunities (we want cross-DEX arb with Ramses)
- Do NOT apply threshold to buildSwapPath() or estimateCosts() (threshold is detection-time only)
- Do NOT modify config.minProfitThreshold directly (use multiplier at detection time)
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes
2. `grep -c "involvesRamses" bot/src/detector/OpportunityDetector.ts` returns >=3 (helper method + 2 call sites)
3. `grep -c "2x for Ramses" bot/src/detector/OpportunityDetector.ts` returns >=2 (rejection messages updated)
4. `pnpm test` passes (existing tests unbroken)
  </verify>
  <done>
OpportunityDetector applies 2x minimum profit threshold to all opportunities involving Ramses pools. Rejection messages clearly indicate the higher threshold for Ramses trades.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add tests validating Ramses V3 price reading and profit threshold</name>
  <files>bot/__tests__/monitor/ramses-price.test.ts</files>
  <action>
Create `bot/__tests__/monitor/ramses-price.test.ts` to validate that Ramses V3 pools are correctly identified as V3 pools and use slot0() price reading.

**Test structure:**

```typescript
import { describe, it, expect, beforeEach } from "vitest";
import { PriceMonitor } from "../../src/monitor/PriceMonitor.js";
import type { PoolConfig } from "../../src/monitor/types.js";

describe("Ramses V3 Price Reading", () => {
  let monitor: PriceMonitor;

  const ramsesPool: PoolConfig = {
    label: "WETH/USDC Ramses V3 (0.05%)",
    dex: "ramses_v3",
    poolAddress: "0x1234567890123456789012345678901234567890", // mock address
    token0: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1", // WETH
    token1: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8", // USDC.e
    decimals0: 18,
    decimals1: 6,
    feeTier: 500,
  };

  // Test 1: isV3Pool recognizes ramses_v3
  it("should identify ramses_v3 as a V3 pool", () => {
    // Access private method via type assertion or test the behavior indirectly
    // by checking that getCallDataForPool returns slot0() calldata
    const callData = (monitor as any).getCallDataForPool(ramsesPool);
    expect(callData).toContain("0x3850c7bd"); // slot0() selector
  });

  // Test 2: Price calculation uses V3 formula
  it("should calculate price from sqrtPriceX96 for ramses_v3 pools", () => {
    const sqrtPriceX96 = BigInt("1461446703485210103287273052203988822378723970342");
    const price = (monitor as any).calculateV3Price(sqrtPriceX96, 18, 6);
    expect(price).toBeGreaterThan(0);
    expect(price).toBeLessThan(10000); // Sanity check for WETH/USDC price
  });
});
```

**Additional test in OpportunityDetector tests (create or extend existing test file):**

```typescript
describe("Ramses Profit Threshold", () => {
  it("should apply 2x threshold for opportunities involving Ramses", () => {
    const detector = new OpportunityDetector({ minProfitThreshold: 0.01 });

    // Mock delta with Ramses on buy side
    const deltaWithRamses: PriceDelta = {
      pair: "weth/usdc",
      buyPool: { pool: { dex: "ramses_v3", ... }, ... },
      sellPool: { pool: { dex: "uniswap_v3", ... }, ... },
      deltaPercent: 1.5,
      timestamp: Date.now(),
    };

    // Expect rejection with netProfit=0.015 (below 0.02 threshold)
    const rejected = jest.fn();
    detector.on("opportunityRejected", rejected);
    detector.analyzeDelta(deltaWithRamses);

    expect(rejected).toHaveBeenCalledWith(
      expect.stringContaining("2x for Ramses"),
      deltaWithRamses
    );
  });
});
```

**Simplified approach if mocking is complex:** Test the `involvesRamses()` logic directly:
```typescript
it("should detect Ramses on buy side", () => {
  const result = (detector as any).involvesRamses({ buyPool: { pool: { dex: "ramses_v3" } }, sellPool: { pool: { dex: "uniswap_v3" } } });
  expect(result).toBe(true);
});

it("should detect Ramses on sell side", () => {
  const result = (detector as any).involvesRamses({ buyPool: { pool: { dex: "uniswap_v3" } }, sellPool: { pool: { dex: "ramses_v3" } } });
  expect(result).toBe(true);
});

it("should return false when no Ramses pools involved", () => {
  const result = (detector as any).involvesRamses({ buyPool: { pool: { dex: "uniswap_v3" } }, sellPool: { pool: { dex: "sushiswap_v3" } } });
  expect(result).toBe(false);
});
```

**Test coverage goals:**
1. Ramses V3 pools use slot0() calldata encoding
2. Ramses V3 pools use V3 price calculation formula
3. involvesRamses() correctly detects Ramses on buy or sell side
4. Profit threshold is 2x for Ramses opportunities
  </action>
  <verify>
`pnpm test -- --run bot/__tests__/monitor/ramses-price.test.ts` passes with all tests green. Minimum 3 test cases passing.
  </verify>
  <done>
Test file exists at bot/__tests__/monitor/ramses-price.test.ts validating Ramses V3 price reading and profit threshold logic. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` - No TypeScript errors
2. `pnpm test` - All tests pass (existing + new Ramses tests)
3. `grep -c '"ramses_v3"' bot/src/config/chains/pools/arbitrum-mainnet.ts` - At least 2 Ramses pools configured
4. `grep 'ramses_v3' bot/src/monitor/PriceMonitor.ts` - isV3Pool updated
5. `grep '2x for Ramses' bot/src/detector/OpportunityDetector.ts` - Threshold multiplier applied
6. Pool count in ARBITRUM_MAINNET_POOLS increased by 2+ (from current count)
7. Dry run output (if running bot) shows Ramses pools being monitored
</verification>

<success_criteria>
Bot monitors 2+ Ramses V3 CL pools, reads prices via slot0(), detects cross-DEX spreads with existing pools, and applies 2x profit threshold to all Ramses opportunities. All tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/09-ramses-v2-adapter/09-02-SUMMARY.md`
</output>
