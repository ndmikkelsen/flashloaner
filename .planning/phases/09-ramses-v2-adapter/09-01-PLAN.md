---
phase: 09-ramses-v2-adapter
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - contracts/src/adapters/RamsesV2Adapter.sol
  - contracts/test/unit/adapters/RamsesV2Adapter.t.sol
  - contracts/test/fork/RamsesForkTest.sol
  - bot/src/monitor/types.ts
autonomous: true
requirements:
  - DEX-02
  - DEX-01 (partial - type extension only)

must_haves:
  truths:
    - "RamsesV2Adapter contract exists and implements IDEXAdapter with same interface as UniswapV3Adapter"
    - "RamsesV2Adapter routes swaps through Ramses V3 SwapRouter (0x4730e03EB4a58A5e20244062D5f9A99bCf5770a6)"
    - "Adapter unit tests pass with mock contracts, fork tests pass against real Ramses pools on Arbitrum"
    - "DEXProtocol type in bot includes 'ramses_v3' as valid option"
  artifacts:
    - path: "contracts/src/adapters/RamsesV2Adapter.sol"
      provides: "On-chain swap adapter for Ramses V3 CL pools"
      min_lines: 150
      exports: ["RamsesV2Adapter"]
    - path: "contracts/test/unit/adapters/RamsesV2Adapter.t.sol"
      provides: "Unit tests for RamsesV2Adapter with mock contracts"
      min_lines: 200
    - path: "contracts/test/fork/RamsesForkTest.sol"
      provides: "Fork tests validating real swaps through Ramses pools"
      min_lines: 100
    - path: "bot/src/monitor/types.ts"
      provides: "Extended DEXProtocol type including 'ramses_v3'"
      contains: "ramses_v3"
  key_links:
    - from: "contracts/src/adapters/RamsesV2Adapter.sol"
      to: "contracts/src/interfaces/IDEXAdapter.sol"
      via: "implements IDEXAdapter"
      pattern: "contract RamsesV2Adapter is IDEXAdapter"
    - from: "contracts/test/unit/adapters/RamsesV2Adapter.t.sol"
      to: "contracts/src/adapters/RamsesV2Adapter.sol"
      via: "import and instantiate"
      pattern: "import.*RamsesV2Adapter"
    - from: "bot/src/monitor/PriceMonitor.ts"
      to: "bot/src/monitor/types.ts"
      via: "imports DEXProtocol type"
      pattern: "DEXProtocol"
---

<objective>
Create on-chain RamsesV2Adapter contract that routes swaps through Ramses V3 SwapRouter using the same Uniswap V3 fork interface, and extend bot types to recognize 'ramses_v3' as a valid DEX protocol.

Purpose: Ramses V3 is a Uniswap V3 fork with identical slot0() and exactInputSingle() ABI. The adapter is ~20 lines reusing existing UniswapV3Adapter pattern. This plan establishes the on-chain routing infrastructure and type system extension. The bot integration (pool config, price monitoring, profit threshold) happens in Plan 02.

Output: Working on-chain adapter validated by unit and fork tests, plus extended type system for bot-side integration.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@contracts/src/adapters/UniswapV3Adapter.sol
@contracts/src/interfaces/IDEXAdapter.sol
@contracts/test/unit/adapters/UniswapV3Adapter.t.sol
@bot/src/monitor/types.ts
@bot/src/monitor/PriceMonitor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RamsesV2Adapter contract mirroring UniswapV3Adapter</name>
  <files>contracts/src/adapters/RamsesV2Adapter.sol</files>
  <action>
Create `contracts/src/adapters/RamsesV2Adapter.sol` by copying the UniswapV3Adapter pattern and updating the router/quoter addresses.

**Pattern to follow:** Copy `contracts/src/adapters/UniswapV3Adapter.sol` structure exactly. The only differences are:
1. Contract name: `RamsesV2Adapter`
2. SwapRouter address: `0x4730e03EB4a58A5e20244062D5f9A99bCf5770a6`
3. QuoterV2 address: `0x00d4FeA3Dd90C4480992f9c7Ea13b8a6A8F7E124`
4. Contract documentation updated to reference Ramses V3 instead of Uniswap V3

**Why this works:** Ramses V3 is a Uniswap V3 fork with identical ABI. The ISwapRouter and IQuoterV2 interfaces from UniswapV3Adapter.sol work without modification.

**Implementation steps:**
1. Copy UniswapV3Adapter.sol to RamsesV2Adapter.sol
2. Replace contract name: `contract RamsesV2Adapter is IDEXAdapter`
3. Update NatSpec comments to mention Ramses V3
4. Keep the same constructor signature: `constructor(address _swapRouter, address _quoter)`
5. Keep all internal functions unchanged (_swapSingle, _swapMultiHop, _encodePath)
6. Keep error handling identical

**What NOT to change:**
- Interface imports (IDEXAdapter, ISwapRouter, IQuoterV2)
- Function signatures (swap, getAmountOut)
- extraData encoding/decoding logic
- Fee tier validation (Ramses V3 uses same fee tiers as Uniswap V3)

**Verification point:** The diff between UniswapV3Adapter.sol and RamsesV2Adapter.sol should be <30 lines (contract name, NatSpec comments only).
  </action>
  <verify>
1. `forge build` compiles without errors
2. `RamsesV2Adapter.sol` exists and implements IDEXAdapter
3. Contract has immutable `swapRouter` and `quoter` addresses
4. Contract has `swap()` and `getAmountOut()` functions with same signatures as UniswapV3Adapter
5. `grep -c "Ramses" contracts/src/adapters/RamsesV2Adapter.sol` returns >5 (NatSpec updated)
  </verify>
  <done>
RamsesV2Adapter.sol exists at contracts/src/adapters/ and compiles successfully. Contract mirrors UniswapV3Adapter structure with Ramses-specific router/quoter addresses.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for RamsesV2Adapter</name>
  <files>contracts/test/unit/adapters/RamsesV2Adapter.t.sol</files>
  <action>
Create `contracts/test/unit/adapters/RamsesV2Adapter.t.sol` by copying the UniswapV3Adapter test pattern.

**Pattern to follow:** Copy `contracts/test/unit/adapters/UniswapV3Adapter.t.sol` structure. The mock contracts (MockSwapRouter, MockQuoterV2, MockToken) work for Ramses because the ABI is identical.

**Test cases to include (same as UniswapV3Adapter tests):**
1. `test_Constructor` - Verify router/quoter addresses set correctly
2. `test_SwapSingle_Success` - Single-hop swap with valid fee tier
3. `test_SwapSingle_ZeroAmountIn` - Revert on zero input
4. `test_SwapSingle_ZeroAmountOut` - Revert when router returns 0
5. `test_SwapMultiHop_Success` - Multi-hop swap through intermediates
6. `test_GetAmountOut_Single` - Off-chain quote for single hop
7. `test_GetAmountOut_MultiHop` - Off-chain quote for multi-hop

**Implementation steps:**
1. Copy UniswapV3Adapter.t.sol to RamsesV2Adapter.t.sol
2. Replace all `UniswapV3Adapter` references with `RamsesV2Adapter`
3. Update test contract name: `contract RamsesV2AdapterTest is Test`
4. Keep all mock contracts unchanged (MockToken, MockSwapRouter, MockQuoterV2)
5. Keep test logic identical (same fee tiers, same input amounts, same assertions)

**Why reuse mocks:** The mock contracts simulate Uniswap V3 behavior, which is exactly what Ramses V3 implements. No Ramses-specific mocking needed.
  </action>
  <verify>
`forge test --match-contract RamsesV2AdapterTest` passes with all tests green. Minimum 7 test functions passing.
  </verify>
  <done>
Test file exists at contracts/test/unit/adapters/RamsesV2Adapter.t.sol with 7+ passing tests. All standard adapter behaviors (single-hop, multi-hop, quotes, error cases) validated.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create fork test for RamsesV2Adapter with real Ramses pools</name>
  <files>contracts/test/fork/RamsesForkTest.sol</files>
  <action>
Create `contracts/test/fork/RamsesForkTest.sol` to validate real swaps through Ramses V3 pools on Arbitrum mainnet fork.

**Test setup:**
1. Inherit from `ForkTestBase` (existing pattern from contracts/test/fork/ForkTestBase.sol)
2. Deploy RamsesV2Adapter in setUp() with real Ramses addresses:
   - SwapRouter: `0x4730e03EB4a58A5e20244062D5f9A99bCf5770a6`
   - QuoterV2: `0x00d4FeA3Dd90C4480992f9c7Ea13b8a6A8F7E124`

**Test case: Real WETH/USDC swap**
Use a known liquid Ramses V3 pool:
- Pool: Ramses V3 WETH/USDC 0.05% (discover address via Ramses factory or use 0x... if known)
- Tokens: WETH (`0x82af49447d8a07e3bd95bd0d56f35241523fbab1`), USDC.e (`0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8`)
- Fee tier: 500 (0.05%)
- Input: 1 WETH
- Expected: >1000 USDC (verify output is non-zero and reasonable)

**Test implementation pattern:**
```solidity
function test_RamsesV3_WETH_USDC_Swap() public {
    // 1. Deal WETH to test contract
    deal(WETH, address(this), 1 ether);

    // 2. Approve adapter
    IERC20(WETH).approve(address(adapter), 1 ether);

    // 3. Encode extraData (fee tier 500)
    bytes memory extraData = abi.encode(uint24(500));

    // 4. Execute swap
    uint256 usdcOut = adapter.swap(WETH, USDC, 1 ether, 0, extraData);

    // 5. Assert output is reasonable (>1000 USDC, <2000 USDC at ~$1800 ETH)
    assertGt(usdcOut, 1000e6);
    assertLt(usdcOut, 3000e6);
}
```

**Pool discovery fallback:** If Ramses pool addresses are unknown, use factory to discover:
```solidity
address factory = 0xd0019e86edB35E1fedaaB03aED5c3c60f115d28b;
address pool = IRamsesV3Factory(factory).getPool(WETH, USDC, 500);
require(pool != address(0), "Pool does not exist");
```

**What to avoid:**
- Do NOT hardcode swap output expectations (price varies with market)
- Do NOT use pools with zero liquidity (check pool.liquidity() > 0)
- Do NOT test against deprecated Ramses V2 pools (only V3 CL pools)

**Environment requirement:** Fork tests require `ARBITRUM_RPC_URL` env var. Test will be skipped in CI if RPC is unavailable (existing pattern from other fork tests).
  </action>
  <verify>
1. `ARBITRUM_RPC_URL=<your-rpc> forge test --match-contract RamsesForkTest --fork-url $ARBITRUM_RPC_URL` passes
2. Swap executes on-chain (no revert)
3. Output amount is non-zero and within reasonable bounds
4. Test completes in <10 seconds (fork fetch time)
  </verify>
  <done>
Fork test file exists at contracts/test/fork/RamsesForkTest.sol and passes when run against Arbitrum mainnet fork. Real swap through Ramses V3 SwapRouter succeeds with reasonable output.
  </done>
</task>

<task type="auto">
  <name>Task 4: Extend DEXProtocol type in bot to include 'ramses_v3'</name>
  <files>bot/src/monitor/types.ts</files>
  <action>
Update the `DEXProtocol` type in `bot/src/monitor/types.ts` to add `"ramses_v3"` as a valid DEX protocol option.

**Current type definition (line 4):**
```typescript
export type DEXProtocol = "uniswap_v2" | "uniswap_v3" | "sushiswap" | "sushiswap_v3" | "camelot_v2" | "camelot_v3";
```

**Updated type definition:**
```typescript
export type DEXProtocol = "uniswap_v2" | "uniswap_v3" | "sushiswap" | "sushiswap_v3" | "camelot_v2" | "camelot_v3" | "ramses_v3";
```

**Why this is sufficient for Plan 01:** This change extends the type system to accept Ramses V3 pools. The PriceMonitor already handles "ramses_v3" correctly because:
1. `getCallDataForPool()` falls through to Uniswap V3 branch (slot0) for unknown V3 protocols
2. `decodePriceFromResult()` follows the same path
3. `isV3Pool()` needs updating, but that happens in Plan 02 when we add pool config

**What NOT to do:**
- Do NOT add "ramses_v3" to PriceMonitor.ts switch cases yet (that's Plan 02)
- Do NOT add Ramses pool config entries yet (that's Plan 02)
- Do NOT add profit threshold logic yet (that's Plan 02)

**Verification:** After this change, TypeScript should accept pool configs with `dex: "ramses_v3"` without type errors.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes (no type errors)
2. `grep -c '"ramses_v3"' bot/src/monitor/types.ts` returns 1 (type updated)
3. All existing bot tests still pass: `pnpm test`
  </verify>
  <done>
DEXProtocol type in bot/src/monitor/types.ts includes "ramses_v3" as a valid option. TypeScript compilation succeeds. Existing tests unbroken.
  </done>
</task>

</tasks>

<verification>
1. `forge build` - All contracts compile without errors
2. `forge test --match-contract RamsesV2AdapterTest` - Unit tests pass (7+ tests green)
3. `ARBITRUM_RPC_URL=<rpc> forge test --match-contract RamsesForkTest --fork-url $ARBITRUM_RPC_URL` - Fork test passes with real Ramses swap
4. `pnpm exec tsc --noEmit` - No TypeScript type errors
5. `pnpm test` - All existing bot tests pass
6. `wc -l contracts/src/adapters/RamsesV2Adapter.sol` - File exists with 150+ lines
7. `grep "ramses_v3" bot/src/monitor/types.ts` - Type extension present
</verification>

<success_criteria>
RamsesV2Adapter contract exists and successfully routes swaps through Ramses V3 SwapRouter in both unit and fork tests. Bot type system recognizes "ramses_v3" as a valid DEX protocol. All tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/09-ramses-v2-adapter/09-01-SUMMARY.md`
</output>
