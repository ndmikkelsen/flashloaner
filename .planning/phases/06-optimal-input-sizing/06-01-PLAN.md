---
phase: 06-optimal-input-sizing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/src/optimizer/InputOptimizer.ts
  - bot/src/optimizer/types.ts
  - bot/__tests__/optimizer/InputOptimizer.test.ts
autonomous: true
requirements:
  - SIZE-01
  - SIZE-02
  - SIZE-03

must_haves:
  truths:
    - "InputOptimizer computes optimal trade size for V2 pools using constant-product formula"
    - "InputOptimizer computes optimal trade size for V3 pools using virtual reserve approximation"
    - "Optimization terminates within 100ms and 3 iterations max, falling back to conservative fixed size on timeout"
  artifacts:
    - path: "bot/src/optimizer/InputOptimizer.ts"
      provides: "Ternary search optimizer with timeout and iteration cap"
      exports: ["InputOptimizer"]
      min_lines: 150
    - path: "bot/src/optimizer/types.ts"
      provides: "Type definitions for optimizer config and output"
      exports: ["InputOptimizerConfig", "OptimizationResult"]
      min_lines: 30
    - path: "bot/__tests__/optimizer/InputOptimizer.test.ts"
      provides: "Unit tests for V2/V3 optimization, timeout, and fallback behavior"
      min_lines: 200
  key_links:
    - from: "bot/src/optimizer/InputOptimizer.ts"
      to: "bot/src/monitor/types.ts"
      via: "import PriceSnapshot"
      pattern: "PriceSnapshot"
    - from: "bot/src/optimizer/InputOptimizer.ts"
      to: "bot/src/detector/types.ts"
      via: "import SwapPath"
      pattern: "SwapPath"
---

<objective>
Create the InputOptimizer module that computes optimal trade size per opportunity using ternary search over pool liquidity depth, with timeout and iteration cap for production safety.

Purpose: Replace fixed defaultInputAmount with per-opportunity sizing based on pool depth. V2 pools use constant-product formula, V3 pools use virtual reserve approximation. The optimizer runs off-chain with no RPC calls in the hot path, completing within 100ms or falling back to conservative fixed size.

Output: New `bot/src/optimizer/` module with InputOptimizer class, type definitions, and comprehensive unit tests.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@bot/src/detector/OpportunityDetector.ts
@bot/src/detector/types.ts
@bot/src/monitor/types.ts
@bot/src/monitor/PriceMonitor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create optimizer type definitions</name>
  <files>bot/src/optimizer/types.ts</files>
  <action>
Create `bot/src/optimizer/types.ts` with type definitions for the InputOptimizer.

**Types to define:**

```typescript
/** Configuration for InputOptimizer */
export interface InputOptimizerConfig {
  /** Maximum iterations for ternary search. Default: 3 */
  maxIterations?: number;
  /** Timeout in milliseconds. Default: 100 */
  timeoutMs?: number;
  /** Fallback input amount when optimization fails or times out. Default: 10 */
  fallbackAmount?: number;
  /** Minimum input amount to consider. Default: 1 */
  minAmount?: number;
  /** Maximum input amount to consider. Default: 1000 */
  maxAmount?: number;
  /** Convergence threshold (stop when search space < this). Default: 0.01 */
  convergenceThreshold?: number;
}

/** Result from input optimization */
export interface OptimizationResult {
  /** Optimal input amount in base token units */
  optimalAmount: number;
  /** Expected net profit at optimal amount */
  expectedProfit: number;
  /** Number of iterations used */
  iterations: number;
  /** Time taken in milliseconds */
  durationMs: number;
  /** Whether optimization completed successfully */
  converged: boolean;
  /** Reason for fallback if converged=false */
  fallbackReason?: "timeout" | "max_iterations" | "no_profitable_size";
}
```

**Import dependencies:**
- No external imports needed for type definitions

**Export all types.**
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes (no type errors)
2. File exports `InputOptimizerConfig` and `OptimizationResult`
3. All fields have JSDoc comments explaining their purpose
  </verify>
  <done>
Type definitions file exists at `bot/src/optimizer/types.ts` with InputOptimizerConfig and OptimizationResult exported. File compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement InputOptimizer with ternary search</name>
  <files>bot/src/optimizer/InputOptimizer.ts</files>
  <action>
Create `bot/src/optimizer/InputOptimizer.ts` implementing ternary search optimization with timeout and iteration cap.

**Class structure:**

```typescript
import type { PriceSnapshot } from "../monitor/types.js";
import type { SwapPath, SwapStep } from "../detector/types.js";
import type { InputOptimizerConfig, OptimizationResult } from "./types.js";

/**
 * Computes optimal trade size per opportunity using ternary search over pool liquidity depth.
 * Uses constant-product formula for V2 pools and virtual reserve approximation for V3 pools.
 * Completes within 100ms or falls back to conservative fixed size.
 */
export class InputOptimizer {
  private readonly config: Required<InputOptimizerConfig>;

  constructor(config: InputOptimizerConfig = {}) {
    this.config = {
      maxIterations: config.maxIterations ?? 3,
      timeoutMs: config.timeoutMs ?? 100,
      fallbackAmount: config.fallbackAmount ?? 10,
      minAmount: config.minAmount ?? 1,
      maxAmount: config.maxAmount ?? 1000,
      convergenceThreshold: config.convergenceThreshold ?? 0.01,
    };
  }

  /**
   * Compute optimal input amount for a swap path.
   * Uses ternary search to maximize net profit over the input amount space.
   */
  optimize(
    path: SwapPath,
    profitFunction: (inputAmount: number) => number,
  ): OptimizationResult {
    const startTime = Date.now();

    let left = this.config.minAmount;
    let right = this.config.maxAmount;
    let iterations = 0;
    let bestAmount = this.config.fallbackAmount;
    let bestProfit = profitFunction(bestAmount);

    // Ternary search: find maximum of unimodal profit function
    while (iterations < this.config.maxIterations) {
      // Check timeout
      if (Date.now() - startTime > this.config.timeoutMs) {
        return {
          optimalAmount: this.config.fallbackAmount,
          expectedProfit: profitFunction(this.config.fallbackAmount),
          iterations,
          durationMs: Date.now() - startTime,
          converged: false,
          fallbackReason: "timeout",
        };
      }

      // Check convergence
      if (right - left < this.config.convergenceThreshold) {
        break;
      }

      // Ternary search iteration
      const mid1 = left + (right - left) / 3;
      const mid2 = right - (right - left) / 3;

      const profit1 = profitFunction(mid1);
      const profit2 = profitFunction(mid2);

      // Track best seen so far
      if (profit1 > bestProfit) {
        bestProfit = profit1;
        bestAmount = mid1;
      }
      if (profit2 > bestProfit) {
        bestProfit = profit2;
        bestAmount = mid2;
      }

      // Narrow search space
      if (profit1 < profit2) {
        left = mid1;
      } else {
        right = mid2;
      }

      iterations++;
    }

    const durationMs = Date.now() - startTime;

    // Check if we hit iteration cap
    if (iterations >= this.config.maxIterations) {
      return {
        optimalAmount: bestAmount,
        expectedProfit: bestProfit,
        iterations,
        durationMs,
        converged: false,
        fallbackReason: "max_iterations",
      };
    }

    // Check if no profitable size exists
    if (bestProfit <= 0) {
      return {
        optimalAmount: this.config.fallbackAmount,
        expectedProfit: profitFunction(this.config.fallbackAmount),
        iterations,
        durationMs,
        converged: false,
        fallbackReason: "no_profitable_size",
      };
    }

    // Success: converged to optimal amount
    return {
      optimalAmount: bestAmount,
      expectedProfit: bestProfit,
      iterations,
      durationMs,
      converged: true,
    };
  }

  /**
   * Compute virtual reserve for a swap step.
   * V2: uses actual reserves from getReserves()
   * V3: computes virtual reserves from L and sqrtPriceX96
   */
  computeVirtualReserve(
    snapshot: PriceSnapshot,
    tokenIn: string,
    decimalsIn: number,
  ): number | undefined {
    const pool = snapshot.pool;

    // V2: use actual reserves
    if (snapshot.reserves) {
      const isToken0 = tokenIn.toLowerCase() === pool.token0.toLowerCase();
      const reserveRaw = isToken0 ? snapshot.reserves[0] : snapshot.reserves[1];
      return Number(reserveRaw) / 10 ** decimalsIn;
    }

    // V3: compute virtual reserves from L and sqrtPriceX96
    if (snapshot.liquidity !== undefined && snapshot.sqrtPriceX96 !== undefined) {
      const L = Number(snapshot.liquidity);
      const Q96 = Number(2n ** 96n);
      const sqrtP = Number(snapshot.sqrtPriceX96) / Q96;
      if (sqrtP === 0 || L === 0) return undefined;

      const isToken0 = tokenIn.toLowerCase() === pool.token0.toLowerCase();
      if (isToken0) {
        // x_virtual = L / sqrtP (raw token0 units)
        return (L / sqrtP) / 10 ** decimalsIn;
      } else {
        // y_virtual = L * sqrtP (raw token1 units)
        return (L * sqrtP) / 10 ** decimalsIn;
      }
    }

    return undefined;
  }
}
```

**Key implementation notes:**
- Ternary search assumes profit function is unimodal (single peak) over input amount
- Timeout check happens at start of each iteration (not mid-iteration)
- Track best seen amount/profit during search (not just final convergence point)
- Fallback to conservative fixed size on timeout or max iterations
- No RPC calls in hot path — all data comes from PriceSnapshot
- computeVirtualReserve matches OpportunityDetector's existing implementation (copy the logic)

**Error handling:**
- Invalid snapshot data (missing reserves/liquidity) returns undefined from computeVirtualReserve
- Profit function returning NaN or Infinity is caller's responsibility to handle
- Negative profit triggers "no_profitable_size" fallback

**Do NOT:**
- Make RPC calls in optimization loop
- Use recursive ternary search (stack overflow risk)
- Assume profit function is monotonic (it's not — slippage increases with size)
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes
2. File exports `InputOptimizer` class
3. `optimize()` method signature matches: `(path: SwapPath, profitFunction: (inputAmount: number) => number) => OptimizationResult`
4. `computeVirtualReserve()` method exists and returns `number | undefined`
5. No import errors for PriceSnapshot, SwapPath, SwapStep
  </verify>
  <done>
InputOptimizer class exists at `bot/src/optimizer/InputOptimizer.ts` with ternary search implementation, timeout/iteration cap, and virtual reserve computation. File compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive unit tests for InputOptimizer</name>
  <files>bot/__tests__/optimizer/InputOptimizer.test.ts</files>
  <action>
Create `bot/__tests__/optimizer/InputOptimizer.test.ts` with comprehensive test coverage.

**Test structure:**

```typescript
import { describe, it, expect, vi } from "vitest";
import { InputOptimizer } from "../../src/optimizer/InputOptimizer.js";
import type { SwapPath } from "../../src/detector/types.js";
import type { PriceSnapshot, PoolConfig } from "../../src/monitor/types.js";

// Helper to create mock SwapPath
function makeSwapPath(): SwapPath {
  return {
    steps: [],
    baseToken: "0x0000000000000000000000000000000000000000",
    label: "Test path",
  };
}

// Helper to create mock PriceSnapshot
function makeSnapshot(opts: {
  reserves?: [bigint, bigint];
  liquidity?: bigint;
  sqrtPriceX96?: bigint;
}): PriceSnapshot {
  return {
    pool: {
      label: "Test pool",
      dex: "uniswap_v2",
      poolAddress: "0x0000000000000000000000000000000000000001",
      token0: "0x0000000000000000000000000000000000000002",
      token1: "0x0000000000000000000000000000000000000003",
      decimals0: 18,
      decimals1: 18,
    },
    price: 1.0,
    inversePrice: 1.0,
    blockNumber: 1000000,
    timestamp: Date.now(),
    ...opts,
  };
}
```

**Test suites:**

1. **"construction"** — Test default config values, custom config accepted

2. **"optimize with simple profit function"** — Test basic ternary search:
   - Convex profit function (e.g., `x => -(x-50)^2 + 100`) finds optimal at x=50
   - Linear profit function finds boundary
   - Constant profit function converges to any value in range

3. **"optimize with iteration cap"** — Set maxIterations=1, verify fallbackReason="max_iterations"

4. **"optimize with timeout"** — Set timeoutMs=1, verify fallbackReason="timeout" (use slow profit function with delay)

5. **"optimize with no profitable size"** — Profit function always returns negative, verify fallbackReason="no_profitable_size"

6. **"optimize convergence"** — Normal convex function converges within 3 iterations, converged=true

7. **"computeVirtualReserve for V2 pools"** — Test with reserves data:
   - Token0 input returns reserve0 / 10^decimals0
   - Token1 input returns reserve1 / 10^decimals1
   - Case insensitive address matching

8. **"computeVirtualReserve for V3 pools"** — Test with liquidity + sqrtPriceX96:
   - Token0 input returns L / sqrtP / 10^decimals0
   - Token1 input returns L * sqrtP / 10^decimals1
   - Returns undefined when L=0 or sqrtP=0

9. **"computeVirtualReserve fallback"** — Returns undefined when no reserve data available

10. **"realistic profit function with slippage"** — Test with profit function that decreases at high input (slippage dominates):
    ```typescript
    // Simulate: gross profit increases linearly, slippage increases quadratically
    const profitFn = (x: number) => {
      const grossProfit = x * 0.01; // 1% spread
      const slippage = x * x * 0.0001; // quadratic slippage
      return grossProfit - slippage;
    };
    // Optimal should be around x=50 (where marginal profit = marginal slippage)
    ```

**Assertions:**
- Verify `optimalAmount` is within expected range
- Verify `expectedProfit` matches profitFunction(optimalAmount)
- Verify `iterations` <= maxIterations
- Verify `durationMs` < timeoutMs (when converged=true)
- Verify `converged` flag matches expectations
- Verify `fallbackReason` is set when converged=false

**Use `toBeCloseTo()` for floating point comparisons.**
  </action>
  <verify>
`pnpm test -- --run bot/__tests__/optimizer/InputOptimizer.test.ts` passes with 10+ test cases green.
  </verify>
  <done>
Test file exists at `bot/__tests__/optimizer/InputOptimizer.test.ts` with 10+ passing tests covering ternary search, timeout, iteration cap, V2/V3 reserve computation, and realistic slippage scenarios.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` — no type errors
2. `pnpm test -- --run bot/__tests__/optimizer/InputOptimizer.test.ts` — all optimizer tests pass
3. `pnpm test` — all existing tests still pass (no regressions)
4. New module exports are available: `InputOptimizer`, `InputOptimizerConfig`, `OptimizationResult`
5. File structure follows existing patterns: `src/optimizer/` and `__tests__/optimizer/`
</verification>

<success_criteria>
InputOptimizer module exists with ternary search implementation, timeout/iteration cap, V2/V3 virtual reserve computation, and comprehensive unit tests. All tests pass. Module is ready for integration into OpportunityDetector.
</success_criteria>

<output>
After completion, create `.planning/phases/06-optimal-input-sizing/06-01-SUMMARY.md`
</output>
