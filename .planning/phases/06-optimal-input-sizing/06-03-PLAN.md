---
phase: 06-optimal-input-sizing
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - bot/src/bot.ts
  - bot/__tests__/integration/sizing.test.ts
autonomous: true
requirements:
  - SIZE-01
  - SIZE-02
  - SIZE-03

must_haves:
  truths:
    - "Dry-run output displays per-opportunity input amounts and shows variation across opportunities (not uniform)"
    - "Dry-run output shows optimization metadata (iterations, duration, converged flag) for each opportunity"
    - "Integration test validates end-to-end sizing with real pool data patterns (deep vs thin pools)"
  artifacts:
    - path: "bot/src/bot.ts"
      provides: "Enhanced dry-run output with input sizing visibility"
      contains: "optimizationResult"
      min_lines: 100
    - path: "bot/__tests__/integration/sizing.test.ts"
      provides: "End-to-end integration test for optimal sizing"
      min_lines: 150
  key_links:
    - from: "bot/src/bot.ts"
      to: "bot/src/detector/types.ts"
      via: "read opportunity.optimizationResult"
      pattern: "optimizationResult"
---

<objective>
Enhance dry-run output to display per-opportunity input amounts and optimization metadata, and add an integration test validating end-to-end optimal sizing behavior.

Purpose: Operators need visibility into how the bot sizes trades across different opportunities. Dry-run output should show varying input amounts correlated to pool depth, plus optimization metadata for debugging. Integration test validates the full flow from pool data through optimization to opportunity output.

Output: Updated dry-run display in bot.ts and comprehensive integration test file.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/06-optimal-input-sizing/06-01-SUMMARY.md
@.planning/phases/06-optimal-input-sizing/06-02-SUMMARY.md

@bot/src/bot.ts
@bot/src/detector/types.ts
@bot/src/optimizer/types.ts
@bot/__tests__/detector/OpportunityDetector.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance dry-run output with input sizing visibility</name>
  <files>bot/src/bot.ts</files>
  <action>
Update `bot/src/bot.ts` to display per-opportunity input amounts and optimization metadata in dry-run output.

**Find the opportunityFound event handler** (search for `detector.on("opportunityFound"`).

**Current format likely shows:**
```
Opportunity #1: Buy WETH/USDC (UniV2) → Sell WETH/USDC (Sushi)
  Price delta: 1.23%
  Gross profit: 0.0123 ETH
  Net profit: 0.0089 ETH (0.89%)
  Costs: flash loan 0.0001, gas 0.0003, slippage 0.0030
```

**Enhance to show input amount and optimization metadata:**

```typescript
detector.on("opportunityFound", (opportunity: ArbitrageOpportunity) => {
  opportunityCount++;

  console.log(`\nOpportunity #${opportunityCount}: ${opportunity.path.label}`);
  console.log(`  Price delta: ${opportunity.priceDelta.deltaPercent.toFixed(2)}%`);

  // Show input amount (highlight when optimized vs fixed)
  if (opportunity.optimizationResult) {
    console.log(`  Input amount: ${opportunity.inputAmount.toFixed(4)} ETH (optimized)`);
    console.log(`    Optimization: ${opportunity.optimizationResult.iterations} iterations, ` +
                `${opportunity.optimizationResult.durationMs.toFixed(1)}ms, ` +
                `converged=${opportunity.optimizationResult.converged}`);
    if (opportunity.optimizationResult.fallbackReason) {
      console.log(`    Fallback: ${opportunity.optimizationResult.fallbackReason}`);
    }
  } else {
    console.log(`  Input amount: ${opportunity.inputAmount.toFixed(4)} ETH (fixed default)`);
  }

  console.log(`  Gross profit: ${opportunity.grossProfit.toFixed(6)} ETH`);
  console.log(`  Net profit: ${opportunity.netProfit.toFixed(6)} ETH (${opportunity.netProfitPercent.toFixed(2)}%)`);

  const { flashLoanFee, gasCost, l1DataFee, slippageCost } = opportunity.costs;
  const costParts = [
    `flash loan ${flashLoanFee.toFixed(6)}`,
    `gas ${gasCost.toFixed(6)}`,
    ...(l1DataFee !== undefined ? [`L1 data ${l1DataFee.toFixed(6)}`] : []),
    `slippage ${slippageCost.toFixed(6)}`,
  ];
  console.log(`  Costs: ${costParts.join(", ")}`);
});
```

**Key additions:**
- Display input amount with label "(optimized)" or "(fixed default)"
- Show optimization metadata: iterations, duration, converged flag
- Show fallback reason when converged=false
- Preserve existing cost breakdown format

**Find the location in bot.ts:**
- Search for `detector.on("opportunityFound"` or similar event handler
- If bot.ts doesn't have this handler yet, search for where opportunities are logged (might be in a different dry-run handler)
- If no dry-run logging exists yet, add the handler after `detector.attach(monitor)`

**Import ArbitrageOpportunity type if not already imported:**
```typescript
import type { ArbitrageOpportunity } from "./detector/types.js";
```
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes
2. Grep for "optimizationResult" in bot.ts — should appear in opportunityFound handler
3. Console.log statements include input amount and optimization metadata
4. Format distinguishes between optimized and fixed default amounts
  </verify>
  <done>
Dry-run output in bot.ts displays per-opportunity input amounts with "(optimized)" or "(fixed default)" label, plus optimization metadata (iterations, duration, converged, fallbackReason). File compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add end-to-end integration test for optimal sizing</name>
  <files>bot/__tests__/integration/sizing.test.ts</files>
  <action>
Create `bot/__tests__/integration/sizing.test.ts` to validate end-to-end optimal input sizing behavior.

**Test file structure:**

```typescript
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { JsonRpcProvider } from "ethers";
import { PriceMonitor } from "../../src/monitor/PriceMonitor.js";
import { OpportunityDetector } from "../../src/detector/OpportunityDetector.js";
import type { ArbitrageOpportunity } from "../../src/detector/types.js";
import type { PriceDelta, PoolConfig } from "../../src/monitor/types.js";

// Mock provider for integration test (no real RPC calls)
class MockProvider extends JsonRpcProvider {
  constructor() {
    super("http://localhost:8545"); // Dummy URL
  }

  async getBlockNumber(): Promise<number> {
    return 19_000_000;
  }

  async call(): Promise<string> {
    // Return mock multicall result with reserves
    // This is simplified — real implementation would need proper encoding
    throw new Error("MockProvider.call() not implemented for this test");
  }
}

describe("Optimal Input Sizing Integration", () => {
  let monitor: PriceMonitor;
  let detector: OpportunityDetector;
  const opportunities: ArbitrageOpportunity[] = [];

  beforeEach(() => {
    opportunities.length = 0;
  });

  afterEach(() => {
    monitor?.stop();
    detector?.detach();
  });

  it("should produce varying input amounts across deep and thin pools", () => {
    // Setup detector with default input = 10
    detector = new OpportunityDetector({
      minProfitThreshold: 0,
      gasPriceGwei: 0,
      maxSlippage: 0.005,
      defaultInputAmount: 10,
    });
    detector.on("error", () => {});
    detector.on("opportunityFound", (opp) => opportunities.push(opp));

    // Simulate two deltas: one with deep pool, one with thin pool

    // Deep pool delta (large reserves → expect larger input amount)
    const deepBuyPool: PoolConfig = {
      label: "WETH/USDC UniV2 (Deep)",
      dex: "uniswap_v2",
      poolAddress: "0x0000000000000000000000000000000000000001",
      token0: "0x0000000000000000000000000000000000000010",
      token1: "0x0000000000000000000000000000000000000020",
      decimals0: 18,
      decimals1: 6,
    };

    const deepSellPool: PoolConfig = {
      label: "WETH/USDC Sushi (Deep)",
      dex: "sushiswap",
      poolAddress: "0x0000000000000000000000000000000000000002",
      token0: "0x0000000000000000000000000000000000000010",
      token1: "0x0000000000000000000000000000000000000020",
      decimals0: 18,
      decimals1: 6,
    };

    const deepDelta: PriceDelta = {
      pair: "0x0000000000000000000000000000000000000010/0x0000000000000000000000000000000000000020",
      buyPool: {
        pool: deepBuyPool,
        price: 2000,
        inversePrice: 1 / 2000,
        blockNumber: 19_000_000,
        timestamp: Date.now(),
        reserves: [
          BigInt("10000000000000000000000"),  // 10,000 WETH
          BigInt("20000000000000"),            // 20,000,000 USDC
        ],
      },
      sellPool: {
        pool: deepSellPool,
        price: 2050,
        inversePrice: 1 / 2050,
        blockNumber: 19_000_000,
        timestamp: Date.now(),
        reserves: [
          BigInt("10000000000000000000000"),  // 10,000 WETH
          BigInt("20500000000000"),            // 20,500,000 USDC
        ],
      },
      deltaPercent: 2.5,
      timestamp: Date.now(),
    };

    // Thin pool delta (small reserves → expect smaller input amount)
    const thinBuyPool: PoolConfig = {
      label: "WETH/USDC UniV2 (Thin)",
      dex: "uniswap_v2",
      poolAddress: "0x0000000000000000000000000000000000000003",
      token0: "0x0000000000000000000000000000000000000010",
      token1: "0x0000000000000000000000000000000000000020",
      decimals0: 18,
      decimals1: 6,
    };

    const thinSellPool: PoolConfig = {
      label: "WETH/USDC Sushi (Thin)",
      dex: "sushiswap",
      poolAddress: "0x0000000000000000000000000000000000000004",
      token0: "0x0000000000000000000000000000000000000010",
      token1: "0x0000000000000000000000000000000000000020",
      decimals0: 18,
      decimals1: 6,
    };

    const thinDelta: PriceDelta = {
      pair: "0x0000000000000000000000000000000000000010/0x0000000000000000000000000000000000000020",
      buyPool: {
        pool: thinBuyPool,
        price: 2000,
        inversePrice: 1 / 2000,
        blockNumber: 19_000_000,
        timestamp: Date.now(),
        reserves: [
          BigInt("10000000000000000000"),  // 10 WETH
          BigInt("20000000000"),           // 20,000 USDC
        ],
      },
      sellPool: {
        pool: thinSellPool,
        price: 2020,
        inversePrice: 1 / 2020,
        blockNumber: 19_000_000,
        timestamp: Date.now(),
        reserves: [
          BigInt("10000000000000000000"),  // 10 WETH
          BigInt("20200000000"),           // 20,200 USDC
        ],
      },
      deltaPercent: 1.0,
      timestamp: Date.now(),
    };

    // Analyze both deltas
    const deepOpp = detector.analyzeDelta(deepDelta);
    const thinOpp = detector.analyzeDelta(thinDelta);

    expect(deepOpp).not.toBeNull();
    expect(thinOpp).not.toBeNull();

    // Both should have optimization results
    expect(deepOpp!.optimizationResult).toBeDefined();
    expect(thinOpp!.optimizationResult).toBeDefined();

    // Deep pool should optimize to larger amount than thin pool
    expect(deepOpp!.inputAmount).toBeGreaterThan(thinOpp!.inputAmount);

    // Both should differ from default (10)
    expect(deepOpp!.inputAmount).not.toBe(10);
    expect(thinOpp!.inputAmount).not.toBe(10);

    // Both should converge within limits
    expect(deepOpp!.optimizationResult!.converged).toBe(true);
    expect(thinOpp!.optimizationResult!.converged).toBe(true);
    expect(deepOpp!.optimizationResult!.durationMs).toBeLessThan(100);
    expect(thinOpp!.optimizationResult!.durationMs).toBeLessThan(100);
  });

  it("should fall back to default when no reserve data", () => {
    detector = new OpportunityDetector({
      minProfitThreshold: 0,
      gasPriceGwei: 0,
      maxSlippage: 0,
      defaultInputAmount: 25,
    });
    detector.on("error", () => {});

    // Delta without reserve data
    const buyPool: PoolConfig = {
      label: "WETH/USDC UniV2",
      dex: "uniswap_v2",
      poolAddress: "0x0000000000000000000000000000000000000001",
      token0: "0x0000000000000000000000000000000000000010",
      token1: "0x0000000000000000000000000000000000000020",
      decimals0: 18,
      decimals1: 6,
    };

    const sellPool: PoolConfig = {
      label: "WETH/USDC Sushi",
      dex: "sushiswap",
      poolAddress: "0x0000000000000000000000000000000000000002",
      token0: "0x0000000000000000000000000000000000000010",
      token1: "0x0000000000000000000000000000000000000020",
      decimals0: 18,
      decimals1: 6,
    };

    const delta: PriceDelta = {
      pair: "0x0000000000000000000000000000000000000010/0x0000000000000000000000000000000000000020",
      buyPool: {
        pool: buyPool,
        price: 2000,
        inversePrice: 1 / 2000,
        blockNumber: 19_000_000,
        timestamp: Date.now(),
        // No reserves
      },
      sellPool: {
        pool: sellPool,
        price: 2100,
        inversePrice: 1 / 2100,
        blockNumber: 19_000_000,
        timestamp: Date.now(),
        // No reserves
      },
      deltaPercent: 5.0,
      timestamp: Date.now(),
    };

    const opp = detector.analyzeDelta(delta);

    expect(opp).not.toBeNull();
    expect(opp!.optimizationResult).toBeUndefined();
    expect(opp!.inputAmount).toBe(25); // Uses defaultInputAmount
  });

  it("should show varying amounts in real scenario with multiple opportunities", () => {
    detector = new OpportunityDetector({
      minProfitThreshold: 0,
      gasPriceGwei: 0,
      maxSlippage: 0.005,
      defaultInputAmount: 10,
    });
    detector.on("error", () => {});
    detector.on("opportunityFound", (opp) => opportunities.push(opp));

    // Create 5 deltas with varying pool depths
    const poolDepths = [
      { reserves: BigInt("100000000000000000000"), label: "Tiny" },      // 100 WETH
      { reserves: BigInt("1000000000000000000000"), label: "Small" },    // 1,000 WETH
      { reserves: BigInt("5000000000000000000000"), label: "Medium" },   // 5,000 WETH
      { reserves: BigInt("10000000000000000000000"), label: "Large" },   // 10,000 WETH
      { reserves: BigInt("50000000000000000000000"), label: "Huge" },    // 50,000 WETH
    ];

    for (let i = 0; i < poolDepths.length; i++) {
      const depth = poolDepths[i];
      const buyPool: PoolConfig = {
        label: `WETH/USDC UniV2 (${depth.label})`,
        dex: "uniswap_v2",
        poolAddress: `0x000000000000000000000000000000000000000${i + 1}`,
        token0: "0x0000000000000000000000000000000000000010",
        token1: "0x0000000000000000000000000000000000000020",
        decimals0: 18,
        decimals1: 6,
      };

      const sellPool: PoolConfig = {
        label: `WETH/USDC Sushi (${depth.label})`,
        dex: "sushiswap",
        poolAddress: `0x000000000000000000000000000000000000010${i + 1}`,
        token0: "0x0000000000000000000000000000000000000010",
        token1: "0x0000000000000000000000000000000000000020",
        decimals0: 18,
        decimals1: 6,
      };

      const delta: PriceDelta = {
        pair: "0x0000000000000000000000000000000000000010/0x0000000000000000000000000000000000000020",
        buyPool: {
          pool: buyPool,
          price: 2000,
          inversePrice: 1 / 2000,
          blockNumber: 19_000_000,
          timestamp: Date.now(),
          reserves: [
            depth.reserves,
            depth.reserves * 2000n / 1_000_000_000_000n, // USDC reserves (6 decimals)
          ],
        },
        sellPool: {
          pool: sellPool,
          price: 2020,
          inversePrice: 1 / 2020,
          blockNumber: 19_000_000,
          timestamp: Date.now(),
          reserves: [
            depth.reserves,
            depth.reserves * 2020n / 1_000_000_000_000n,
          ],
        },
        deltaPercent: 1.0,
        timestamp: Date.now(),
      };

      detector.analyzeDelta(delta);
    }

    // Should have detected 5 opportunities
    expect(opportunities).toHaveLength(5);

    // All should have optimization results
    for (const opp of opportunities) {
      expect(opp.optimizationResult).toBeDefined();
      expect(opp.optimizationResult!.converged).toBe(true);
    }

    // Amounts should be correlated with pool depth (not perfectly monotonic due to slippage)
    const amounts = opportunities.map((o) => o.inputAmount);

    // At minimum: largest pool should have larger amount than smallest pool
    expect(amounts[4]).toBeGreaterThan(amounts[0]);

    // Standard deviation of amounts should be > 0 (showing variation)
    const mean = amounts.reduce((a, b) => a + b, 0) / amounts.length;
    const variance = amounts.reduce((sum, x) => sum + (x - mean) ** 2, 0) / amounts.length;
    const stdDev = Math.sqrt(variance);
    expect(stdDev).toBeGreaterThan(0);
  });
});
```

**Key validations:**
- Deep pools optimize to larger amounts than thin pools
- Amounts vary across opportunities (not uniform)
- Falls back to default when no reserve data
- All optimizations converge within 100ms
- Standard deviation of amounts > 0 (proving variation)

**Create the directory if needed:**
```bash
mkdir -p bot/__tests__/integration
```
  </action>
  <verify>
`pnpm test -- --run bot/__tests__/integration/sizing.test.ts` passes with 3 integration tests green.
  </verify>
  <done>
Integration test file exists at `bot/__tests__/integration/sizing.test.ts` with 3 passing tests validating end-to-end optimal input sizing behavior. Test proves varying amounts across deep/thin pools.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` — no type errors
2. `pnpm test -- --run bot/__tests__/integration/sizing.test.ts` — integration tests pass
3. `pnpm test` — all existing tests still pass (no regressions)
4. Dry-run output in bot.ts shows input amount with "(optimized)" or "(fixed default)" label
5. Dry-run output shows optimization metadata (iterations, duration, converged, fallbackReason)
6. Integration test validates varying input amounts across different pool depths
</verification>

<success_criteria>
Dry-run output displays per-opportunity input amounts and optimization metadata. Integration test validates end-to-end optimal sizing with varying amounts across deep/thin pools. All tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/06-optimal-input-sizing/06-03-SUMMARY.md`
</output>
