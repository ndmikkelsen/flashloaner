---
phase: 06-optimal-input-sizing
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - bot/src/detector/OpportunityDetector.ts
  - bot/src/detector/types.ts
  - bot/__tests__/detector/OpportunityDetector.test.ts
autonomous: true
requirements:
  - SIZE-01
  - SIZE-02
  - SIZE-03

must_haves:
  truths:
    - "OpportunityDetector uses InputOptimizer to compute per-opportunity input amounts instead of fixed defaultInputAmount"
    - "Opportunity objects contain optimization metadata (iterations, duration, converged flag)"
    - "Detector falls back to defaultInputAmount when optimization fails (timeout or no reserve data)"
  artifacts:
    - path: "bot/src/detector/OpportunityDetector.ts"
      provides: "Integration of InputOptimizer into analyzeDelta flow"
      contains: "new InputOptimizer"
      min_lines: 500
    - path: "bot/src/detector/types.ts"
      provides: "Extended ArbitrageOpportunity with optimization metadata"
      contains: "optimizationResult"
    - path: "bot/__tests__/detector/OpportunityDetector.test.ts"
      provides: "Tests for optimal sizing integration"
      min_lines: 750
  key_links:
    - from: "bot/src/detector/OpportunityDetector.ts"
      to: "bot/src/optimizer/InputOptimizer.ts"
      via: "import and instantiate InputOptimizer"
      pattern: "InputOptimizer"
    - from: "bot/src/detector/OpportunityDetector.ts"
      to: "bot/src/optimizer/types.ts"
      via: "import OptimizationResult"
      pattern: "OptimizationResult"
---

<objective>
Integrate InputOptimizer into OpportunityDetector's analyzeDelta flow, replacing fixed defaultInputAmount with per-opportunity optimal sizing based on pool depth.

Purpose: The hook point is `defaultInputAmount` in `OpportunityDetector.analyzeDelta()`. Replace this with a call to `InputOptimizer.optimize()` using a profit function that wraps the existing cost estimation logic. Store optimization metadata in the opportunity object for observability.

Output: Updated OpportunityDetector with optimal sizing, extended ArbitrageOpportunity type, and tests validating the integration.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/06-optimal-input-sizing/06-01-SUMMARY.md

@bot/src/detector/OpportunityDetector.ts
@bot/src/detector/types.ts
@bot/src/optimizer/InputOptimizer.ts
@bot/src/optimizer/types.ts
@bot/__tests__/detector/OpportunityDetector.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ArbitrageOpportunity type with optimization metadata</name>
  <files>bot/src/detector/types.ts</files>
  <action>
Update `bot/src/detector/types.ts` to add optimization metadata to the `ArbitrageOpportunity` interface.

**Additions:**

```typescript
import type { OptimizationResult } from "../optimizer/types.js";

export interface ArbitrageOpportunity {
  // ... existing fields ...

  /** Optimization result for input amount sizing. Undefined when using fixed defaultInputAmount. */
  optimizationResult?: OptimizationResult;
}
```

**Import statement to add:**
```typescript
import type { OptimizationResult } from "../optimizer/types.js";
```

**Place the new field after `inputAmount` for logical grouping.**

**Do NOT remove or modify existing fields.**
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes
2. `ArbitrageOpportunity` interface includes `optimizationResult?: OptimizationResult`
3. Import of `OptimizationResult` from `../optimizer/types.js` exists
  </verify>
  <done>
ArbitrageOpportunity type extended with optimizationResult field. File compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate InputOptimizer into OpportunityDetector</name>
  <files>bot/src/detector/OpportunityDetector.ts</files>
  <action>
Update `bot/src/detector/OpportunityDetector.ts` to use InputOptimizer for per-opportunity sizing.

**Step 1: Add imports**

```typescript
import { InputOptimizer } from "../optimizer/InputOptimizer.js";
import type { OptimizationResult } from "../optimizer/types.js";
```

**Step 2: Add optimizer instance to class**

In the `OpportunityDetector` class, add a private optimizer field:

```typescript
export class OpportunityDetector extends EventEmitter {
  // ... existing fields ...
  private optimizer: InputOptimizer;

  constructor(config: OpportunityDetectorConfig = {}) {
    super();
    // ... existing config setup ...

    // Initialize optimizer with conservative defaults
    this.optimizer = new InputOptimizer({
      maxIterations: 3,
      timeoutMs: 100,
      fallbackAmount: this.config.defaultInputAmount,
      minAmount: 1,
      maxAmount: Math.min(1000, this.config.defaultInputAmount * 100),
      convergenceThreshold: 0.01,
    });
  }
}
```

**Step 3: Create profit function helper**

Add a private method to create the profit function for optimization:

```typescript
/**
 * Build a profit function for input optimization.
 * Wraps existing cost estimation logic to compute net profit for any input amount.
 */
private buildProfitFunction(path: SwapPath): (inputAmount: number) => number {
  return (inputAmount: number) => {
    const grossProfit = this.calculateGrossProfit(path, inputAmount);
    const costs = this.estimateCosts(path, inputAmount);
    return grossProfit - costs.totalCost;
  };
}
```

**Step 4: Update analyzeDelta to use optimizer**

Replace the line `const inputAmount = this.config.defaultInputAmount;` with optimization logic:

```typescript
analyzeDelta(delta: PriceDelta): ArbitrageOpportunity | null {
  // ... existing stale pool check ...

  const path = this.buildSwapPath(delta);

  // Optimize input amount based on pool depth
  let inputAmount: number;
  let optimizationResult: OptimizationResult | undefined;

  // Check if we have reserve data for optimization
  const hasReserveData = path.steps.some(
    (s) => s.virtualReserveIn !== undefined && s.virtualReserveIn > 0,
  );

  if (hasReserveData) {
    const profitFn = this.buildProfitFunction(path);
    optimizationResult = this.optimizer.optimize(path, profitFn);
    inputAmount = optimizationResult.optimalAmount;
  } else {
    // No reserve data: fall back to fixed amount
    inputAmount = this.config.defaultInputAmount;
  }

  const grossProfit = this.calculateGrossProfit(path, inputAmount);
  const costs = this.estimateCosts(path, inputAmount);
  const netProfit = grossProfit - costs.totalCost;
  const netProfitPercent = (netProfit / inputAmount) * 100;

  if (netProfit < this.config.minProfitThreshold) {
    this.emit(
      "opportunityRejected",
      `Net profit ${netProfit.toFixed(6)} below threshold ${this.config.minProfitThreshold}`,
      delta,
    );
    return null;
  }

  const opportunity: ArbitrageOpportunity = {
    id: randomUUID(),
    path,
    inputAmount,
    grossProfit,
    costs,
    netProfit,
    netProfitPercent,
    priceDelta: delta,
    blockNumber: delta.buyPool.blockNumber,
    timestamp: Date.now(),
    optimizationResult, // Add optimization metadata
  };

  this.emit("opportunityFound", opportunity);
  return opportunity;
}
```

**Step 5: Update analyzeDeltaAsync similarly**

Apply the same optimization logic to `analyzeDeltaAsync()` (the async version used with gasEstimatorFn). The only difference is using `await this.estimateCostsWithL1()` instead of `this.estimateCosts()`.

**Key decisions:**
- Only optimize when reserve data is available (hasReserveData check prevents optimization on stale/missing data)
- Use defaultInputAmount as optimizer's fallbackAmount (consistent behavior)
- maxAmount = min(1000, defaultInputAmount * 100) caps optimization range (prevents absurdly large sizes)
- Store optimizationResult in opportunity for debugging/observability

**Do NOT:**
- Remove existing cost estimation logic
- Change profit calculation formulas
- Break async/sync analyzeDelta duality
- Remove stale pool checks or threshold checks
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes
2. `OpportunityDetector` class has `private optimizer: InputOptimizer` field
3. `analyzeDelta()` calls `this.optimizer.optimize()` when reserve data is available
4. `analyzeDeltaAsync()` has the same optimization logic
5. `ArbitrageOpportunity` objects include `optimizationResult` when optimization was used
6. Grep for `this.config.defaultInputAmount` in analyzeDelta — should only appear in fallback path
  </verify>
  <done>
OpportunityDetector integrates InputOptimizer into analyzeDelta and analyzeDeltaAsync. Opportunities include optimization metadata. Fixed defaultInputAmount is used as fallback when no reserve data available. File compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for optimal sizing</name>
  <files>bot/__tests__/detector/OpportunityDetector.test.ts</files>
  <action>
Update `bot/__tests__/detector/OpportunityDetector.test.ts` to add tests for optimal input sizing integration.

**Add a new test suite at the end of the file:**

```typescript
describe("optimal input sizing", () => {
  it("should use optimizer when V2 reserve data is available", () => {
    detector = new OpportunityDetector({
      minProfitThreshold: 0,
      gasPriceGwei: 0,
      maxSlippage: 0,
      defaultInputAmount: 10,
    });
    detector.on("error", () => {});

    // Build delta with V2 reserves
    const buyPool = makePool({ poolAddress: ADDR.POOL_V2 });
    const sellPool = makePool({
      label: "WETH/USDC Sushi",
      dex: "sushiswap",
      poolAddress: ADDR.POOL_SUSHI,
    });

    const buySnapshot: PriceSnapshot = {
      pool: buyPool,
      price: 2000,
      inversePrice: 1 / 2000,
      blockNumber: 19_000_000,
      timestamp: Date.now(),
      reserves: [
        BigInt("1000000000000000000000"),  // 1000 WETH
        BigInt("2000000000000"),           // 2,000,000 USDC
      ],
    };

    const sellSnapshot: PriceSnapshot = {
      pool: sellPool,
      price: 2020,
      inversePrice: 1 / 2020,
      blockNumber: 19_000_000,
      timestamp: Date.now(),
      reserves: [
        BigInt("1000000000000000000000"),  // 1000 WETH
        BigInt("2020000000000"),           // 2,020,000 USDC
      ],
    };

    const delta: PriceDelta = {
      pair: `${buyPool.token0}/${buyPool.token1}`,
      buyPool: buySnapshot,
      sellPool: sellSnapshot,
      deltaPercent: 1.0,
      timestamp: Date.now(),
    };

    const result = detector.analyzeDelta(delta);

    expect(result).not.toBeNull();
    expect(result!.optimizationResult).toBeDefined();
    expect(result!.optimizationResult!.converged).toBe(true);
    expect(result!.inputAmount).toBeGreaterThan(0);
    // Optimal amount should differ from default (10) for this pool depth
    expect(result!.inputAmount).not.toBe(10);
  });

  it("should fall back to defaultInputAmount when no reserve data", () => {
    detector = new OpportunityDetector({
      minProfitThreshold: 0,
      gasPriceGwei: 0,
      maxSlippage: 0,
      defaultInputAmount: 25,
    });
    detector.on("error", () => {});

    // Delta with no reserve data
    const delta = makeDelta({ buyPrice: 2000, sellPrice: 2100 });
    const result = detector.analyzeDelta(delta);

    expect(result).not.toBeNull();
    expect(result!.optimizationResult).toBeUndefined();
    expect(result!.inputAmount).toBe(25); // Uses defaultInputAmount
  });

  it("should optimize larger amounts for deep pools", () => {
    detector = new OpportunityDetector({
      minProfitThreshold: 0,
      gasPriceGwei: 0,
      maxSlippage: 0,
      defaultInputAmount: 10,
    });
    detector.on("error", () => {});

    const buyPool = makePool({ poolAddress: ADDR.POOL_V2 });
    const sellPool = makePool({
      label: "WETH/USDC Sushi",
      dex: "sushiswap",
      poolAddress: ADDR.POOL_SUSHI,
    });

    // Very deep pool: 10,000 WETH / 20M USDC
    const buySnapshot: PriceSnapshot = {
      pool: buyPool,
      price: 2000,
      inversePrice: 1 / 2000,
      blockNumber: 19_000_000,
      timestamp: Date.now(),
      reserves: [
        BigInt("10000000000000000000000"),  // 10,000 WETH
        BigInt("20000000000000"),            // 20,000,000 USDC
      ],
    };

    const sellSnapshot: PriceSnapshot = {
      pool: sellPool,
      price: 2100,
      inversePrice: 1 / 2100,
      blockNumber: 19_000_000,
      timestamp: Date.now(),
      reserves: [
        BigInt("10000000000000000000000"),  // 10,000 WETH
        BigInt("21000000000000"),            // 21,000,000 USDC
      ],
    };

    const delta: PriceDelta = {
      pair: `${buyPool.token0}/${buyPool.token1}`,
      buyPool: buySnapshot,
      sellPool: sellSnapshot,
      deltaPercent: 5.0,
      timestamp: Date.now(),
    };

    const result = detector.analyzeDelta(delta);

    expect(result).not.toBeNull();
    expect(result!.optimizationResult).toBeDefined();
    expect(result!.optimizationResult!.converged).toBe(true);
    // Deep pool + large spread should allow larger size
    expect(result!.inputAmount).toBeGreaterThan(10);
  });

  it("should optimize smaller amounts for thin pools", () => {
    detector = new OpportunityDetector({
      minProfitThreshold: 0,
      gasPriceGwei: 0,
      maxSlippage: 0.005,
      defaultInputAmount: 100,
    });
    detector.on("error", () => {});

    const buyPool = makePool({ poolAddress: ADDR.POOL_V2 });
    const sellPool = makePool({
      label: "WETH/USDC Sushi",
      dex: "sushiswap",
      poolAddress: ADDR.POOL_SUSHI,
    });

    // Thin pool: only 10 WETH / 20k USDC
    const buySnapshot: PriceSnapshot = {
      pool: buyPool,
      price: 2000,
      inversePrice: 1 / 2000,
      blockNumber: 19_000_000,
      timestamp: Date.now(),
      reserves: [
        BigInt("10000000000000000000"),  // 10 WETH
        BigInt("20000000000"),           // 20,000 USDC
      ],
    };

    const sellSnapshot: PriceSnapshot = {
      pool: sellPool,
      price: 2020,
      inversePrice: 1 / 2020,
      blockNumber: 19_000_000,
      timestamp: Date.now(),
      reserves: [
        BigInt("10000000000000000000"),  // 10 WETH
        BigInt("20200000000"),           // 20,200 USDC
      ],
    };

    const delta: PriceDelta = {
      pair: `${buyPool.token0}/${buyPool.token1}`,
      buyPool: buySnapshot,
      sellPool: sellSnapshot,
      deltaPercent: 1.0,
      timestamp: Date.now(),
    };

    const result = detector.analyzeDelta(delta);

    expect(result).not.toBeNull();
    expect(result!.optimizationResult).toBeDefined();
    // Thin pool should optimize to smaller size than default
    expect(result!.inputAmount).toBeLessThan(100);
  });

  it("should complete optimization within 100ms", () => {
    detector = new OpportunityDetector({
      minProfitThreshold: 0,
      gasPriceGwei: 0,
      maxSlippage: 0,
      defaultInputAmount: 10,
    });
    detector.on("error", () => {});

    const buyPool = makePool({ poolAddress: ADDR.POOL_V2 });
    const sellPool = makePool({
      label: "WETH/USDC Sushi",
      dex: "sushiswap",
      poolAddress: ADDR.POOL_SUSHI,
    });

    const buySnapshot: PriceSnapshot = {
      pool: buyPool,
      price: 2000,
      inversePrice: 1 / 2000,
      blockNumber: 19_000_000,
      timestamp: Date.now(),
      reserves: [
        BigInt("1000000000000000000000"),
        BigInt("2000000000000"),
      ],
    };

    const sellSnapshot: PriceSnapshot = {
      pool: sellPool,
      price: 2020,
      inversePrice: 1 / 2020,
      blockNumber: 19_000_000,
      timestamp: Date.now(),
      reserves: [
        BigInt("1000000000000000000000"),
        BigInt("2020000000000"),
      ],
    };

    const delta: PriceDelta = {
      pair: `${buyPool.token0}/${buyPool.token1}`,
      buyPool: buySnapshot,
      sellPool: sellSnapshot,
      deltaPercent: 1.0,
      timestamp: Date.now(),
    };

    const result = detector.analyzeDelta(delta);

    expect(result).not.toBeNull();
    expect(result!.optimizationResult).toBeDefined();
    expect(result!.optimizationResult!.durationMs).toBeLessThan(100);
  });

  it("should store optimization metadata in opportunity", () => {
    detector = new OpportunityDetector({
      minProfitThreshold: 0,
      gasPriceGwei: 0,
      maxSlippage: 0,
      defaultInputAmount: 10,
    });
    detector.on("error", () => {});

    const buyPool = makePool({ poolAddress: ADDR.POOL_V2 });
    const sellPool = makePool({
      label: "WETH/USDC Sushi",
      dex: "sushiswap",
      poolAddress: ADDR.POOL_SUSHI,
    });

    const buySnapshot: PriceSnapshot = {
      pool: buyPool,
      price: 2000,
      inversePrice: 1 / 2000,
      blockNumber: 19_000_000,
      timestamp: Date.now(),
      reserves: [
        BigInt("1000000000000000000000"),
        BigInt("2000000000000"),
      ],
    };

    const sellSnapshot: PriceSnapshot = {
      pool: sellPool,
      price: 2020,
      inversePrice: 1 / 2020,
      blockNumber: 19_000_000,
      timestamp: Date.now(),
      reserves: [
        BigInt("1000000000000000000000"),
        BigInt("2020000000000"),
      ],
    };

    const delta: PriceDelta = {
      pair: `${buyPool.token0}/${buyPool.token1}`,
      buyPool: buySnapshot,
      sellPool: sellSnapshot,
      deltaPercent: 1.0,
      timestamp: Date.now(),
    };

    const result = detector.analyzeDelta(delta);

    expect(result).not.toBeNull();
    expect(result!.optimizationResult).toBeDefined();
    expect(result!.optimizationResult!.optimalAmount).toBe(result!.inputAmount);
    expect(result!.optimizationResult!.expectedProfit).toBeCloseTo(result!.netProfit, 2);
    expect(result!.optimizationResult!.iterations).toBeGreaterThan(0);
    expect(result!.optimizationResult!.converged).toBeDefined();
  });
});
```

**These tests validate:**
- Optimizer is used when reserve data is available
- Falls back to defaultInputAmount when no reserve data
- Optimizes larger amounts for deep pools
- Optimizes smaller amounts for thin pools
- Completes within 100ms
- Stores optimization metadata in opportunity object

**Place the new suite after the existing "threshold filtering" suite.**
  </action>
  <verify>
`pnpm test -- --run bot/__tests__/detector/OpportunityDetector.test.ts` passes with 6 new optimal sizing tests green (total tests should be 725+).
  </verify>
  <done>
OpportunityDetector test suite includes 6 new tests for optimal input sizing integration. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` — no type errors
2. `pnpm test -- --run bot/__tests__/detector/OpportunityDetector.test.ts` — all detector tests pass including new optimal sizing tests
3. `pnpm test -- --run bot/__tests__/optimizer/InputOptimizer.test.ts` — optimizer tests still pass
4. `pnpm test` — all existing tests still pass (no regressions)
5. ArbitrageOpportunity type includes optimizationResult field
6. OpportunityDetector uses InputOptimizer when reserve data is available
7. OpportunityDetector falls back to defaultInputAmount when no reserve data
</verification>

<success_criteria>
OpportunityDetector integrates InputOptimizer for per-opportunity sizing based on pool depth. ArbitrageOpportunity objects include optimization metadata. Fallback to defaultInputAmount works when no reserve data available. All tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/06-optimal-input-sizing/06-02-SUMMARY.md`
</output>
