---
phase: 10-trader-joe-lb-adapter
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - contracts/src/adapters/TraderJoeLBAdapter.sol
  - contracts/test/unit/adapters/TraderJoeLBAdapter.t.sol
autonomous: true
requirements:
  - DEX-05

must_haves:
  truths:
    - "TraderJoeLBAdapter routes swaps through LBRouter V2.1 with correct bin-step path encoding in fork tests"
    - "Adapter handles pre-transfer token pattern (tokens transferred to LBPair before calling swap())"
    - "Adapter reverts if swap output is below amountOutMin (slippage protection)"
  artifacts:
    - path: "contracts/src/adapters/TraderJoeLBAdapter.sol"
      provides: "On-chain adapter for Trader Joe Liquidity Book V2.1 swaps"
      exports: ["TraderJoeLBAdapter", "ILBRouter", "ILBPair"]
      min_lines: 200
    - path: "contracts/test/unit/adapters/TraderJoeLBAdapter.t.sol"
      provides: "Fork tests validating LB swap execution with real pools"
      contains: "testSwapSingleHopLB"
      min_lines: 150
  key_links:
    - from: "contracts/src/adapters/TraderJoeLBAdapter.sol"
      to: "contracts/src/interfaces/IDEXAdapter.sol"
      via: "implements IDEXAdapter"
      pattern: "contract TraderJoeLBAdapter is IDEXAdapter"
    - from: "contracts/test/unit/adapters/TraderJoeLBAdapter.t.sol"
      to: "contracts/src/adapters/TraderJoeLBAdapter.sol"
      via: "import and test"
      pattern: "import.*TraderJoeLBAdapter"
---

<objective>
Create the on-chain TraderJoeLBAdapter for routing swaps through Trader Joe Liquidity Book V2.1 pools, implementing the pre-transfer token pattern and bin-step path encoding.

Purpose: Trader Joe LB is a bin-based AMM with a fundamentally different swap mechanism than constant-product (UniV2) or concentrated liquidity (UniV3). The LB protocol requires tokens to be transferred to the pool before calling swap(), and paths must be encoded with bin steps and versions. This adapter handles these LB-specific requirements while conforming to the IDEXAdapter interface.

Output: Production TraderJoeLBAdapter contract and comprehensive fork tests validating single-hop and multi-hop LB swaps.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@contracts/src/adapters/UniswapV3Adapter.sol
@contracts/src/adapters/UniswapV2Adapter.sol
@contracts/src/interfaces/IDEXAdapter.sol
@contracts/test/unit/adapters/UniswapV3Adapter.t.sol
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TraderJoeLBAdapter.sol</name>
  <files>contracts/src/adapters/TraderJoeLBAdapter.sol</files>
  <action>
Create `contracts/src/adapters/TraderJoeLBAdapter.sol` implementing IDEXAdapter for Trader Joe Liquidity Book V2.1 swaps.

**Key differences from UniV3 adapter:**
1. **Pre-transfer pattern**: Tokens must be transferred to LBPair BEFORE calling swap() (not approved to router)
2. **Path encoding**: LBRouter.Path struct uses binSteps[] and versions[] arrays (not packed bytes like UniV3)
3. **Bin-step extraData**: Single-hop extraData = abi.encode(uint24 binStep), multi-hop = abi.encode(uint24[] binSteps)

**Contract structure:**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {IDEXAdapter} from "../interfaces/IDEXAdapter.sol";

/// @notice Minimal Trader Joe LBRouter V2.1 interface
interface ILBRouter {
    enum Version {
        V1,
        V2,
        V2_1
    }

    struct Path {
        uint256[] pairBinSteps;
        Version[] versions;
        IERC20[] tokenPath;
    }

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        Path memory path,
        address to,
        uint256 deadline
    ) external returns (uint256 amountOut);
}

/// @notice Minimal Trader Joe LBPair interface
interface ILBPair {
    function swap(bool swapForY, address to) external returns (bytes32 amountsOut);
    function getTokenX() external view returns (IERC20);
    function getTokenY() external view returns (IERC20);
}

/// @title TraderJoeLBAdapter
/// @notice DEX adapter for Trader Joe Liquidity Book V2.1 swaps.
/// @dev Implements IDEXAdapter for single-hop and multi-hop LB swaps.
///
///      extraData encoding:
///      - Single-hop (32 bytes): abi.encode(uint24 binStep)
///        e.g., abi.encode(uint24(25)) for 0.25% bin step
///      - Multi-hop (>32 bytes): abi.encode(uint24[] binSteps)
///        e.g., for tokenA --(25)--> WETH --(15)--> tokenB:
///        abi.encode([uint24(25), uint24(15)])
///        binSteps.length must equal number of hops
///
///      CRITICAL: LB uses pre-transfer pattern — tokens must be sent to LBPair
///      before calling swap(), unlike UniV3 which approves to router.
contract TraderJoeLBAdapter is IDEXAdapter {
    using SafeERC20 for IERC20;

    /// @notice The Trader Joe LBRouter V2.1
    ILBRouter public immutable lbRouter;

    /// @notice Deadline offset added to block.timestamp for swap calls
    uint256 public constant DEADLINE_OFFSET = 300; // 5 minutes

    /// @param _lbRouter The Trader Joe LBRouter V2.1 address (Arbitrum: 0xb4315e873dbcf96ffd0acd8ea43f689d8c20fb30)
    constructor(address _lbRouter) {
        if (_lbRouter == address(0)) revert InvalidToken();
        lbRouter = ILBRouter(_lbRouter);
    }

    /// @inheritdoc IDEXAdapter
    function swap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 amountOutMin,
        bytes calldata extraData
    ) external returns (uint256 amountOut) {
        if (tokenIn == address(0) || tokenOut == address(0)) revert InvalidToken();
        if (amountIn == 0) revert ZeroAmountIn();

        // Pull tokens from caller
        IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);

        // Approve router (LBRouter will handle transfers internally)
        IERC20(tokenIn).safeIncreaseAllowance(address(lbRouter), amountIn);

        if (extraData.length == 32) {
            // Single-hop swap
            uint24 binStep = abi.decode(extraData, (uint24));
            amountOut = _swapSingleHop(tokenIn, tokenOut, amountIn, amountOutMin, binStep);
        } else {
            // Multi-hop swap
            uint24[] memory binSteps = abi.decode(extraData, (uint24[]));
            amountOut = _swapMultiHop(tokenIn, tokenOut, amountIn, amountOutMin, binSteps);
        }

        if (amountOut == 0) revert ZeroAmountOut();
        if (amountOut < amountOutMin) revert SlippageExceeded(amountOut, amountOutMin);

        emit SwapExecuted(tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @inheritdoc IDEXAdapter
    /// @dev For LB, we use the router's view function or return 0 to indicate off-chain quote needed.
    ///      LB quote logic is complex (bin math) — defer to off-chain bot calculation.
    function getAmountOut(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        bytes calldata extraData
    ) external view returns (uint256 amountOut) {
        // LB quote requires iterating through bins — too gas-intensive for view function
        // Bot handles LB price reading via getActiveId() and bin-to-price conversion
        // Return 0 to signal "quote off-chain"
        return 0;
    }

    // ──────────────────────────────────────────────
    // Internal
    // ──────────────────────────────────────────────

    /// @dev Execute a single-hop LB swap through LBRouter
    function _swapSingleHop(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 amountOutMin,
        uint24 binStep
    ) internal returns (uint256 amountOut) {
        // Build Path struct: single hop = 1 binStep, 1 version, 2 tokens
        uint256[] memory binSteps = new uint256[](1);
        binSteps[0] = uint256(binStep);

        ILBRouter.Version[] memory versions = new ILBRouter.Version[](1);
        versions[0] = ILBRouter.Version.V2_1;

        IERC20[] memory tokenPath = new IERC20[](2);
        tokenPath[0] = IERC20(tokenIn);
        tokenPath[1] = IERC20(tokenOut);

        ILBRouter.Path memory path = ILBRouter.Path({
            pairBinSteps: binSteps,
            versions: versions,
            tokenPath: tokenPath
        });

        amountOut = lbRouter.swapExactTokensForTokens(
            amountIn,
            amountOutMin,
            path,
            msg.sender,
            block.timestamp + DEADLINE_OFFSET
        );
    }

    /// @dev Execute a multi-hop LB swap through LBRouter
    function _swapMultiHop(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 amountOutMin,
        uint24[] memory binSteps
    ) internal returns (uint256 amountOut) {
        // Multi-hop: binSteps.length hops = binSteps.length + 1 tokens
        // This adapter does NOT support cross-hop intermediates from extraData
        // Multi-hop LB paths must be constructed by bot (future enhancement)
        revert("TraderJoeLBAdapter: multi-hop not yet supported");
    }
}
```

**Implementation notes:**
- LBRouter address on Arbitrum: `0xb4315e873dbcf96ffd0acd8ea43f689d8c20fb30`
- Bin steps are encoded as uint24 in basis points (25 = 0.25%, 15 = 0.15%)
- All V2.1 LB pools use Version.V2_1 (not V1 or V2)
- Multi-hop support can be deferred — add revert stub for now, implement if needed later
- getAmountOut returns 0 because bin-based quoting is too complex for on-chain view (bot handles off-chain)

**Error handling:**
- Use existing IDEXAdapter errors: InvalidToken, ZeroAmountIn, ZeroAmountOut, SlippageExceeded
- No new custom errors needed
  </action>
  <verify>
1. `forge build` compiles without errors
2. Contract file exists at `contracts/src/adapters/TraderJoeLBAdapter.sol`
3. Contract implements IDEXAdapter interface
4. Contract defines ILBRouter and ILBPair interfaces
5. Grep for "Version.V2_1" confirms correct LB version usage
  </verify>
  <done>
TraderJoeLBAdapter.sol exists and compiles. Adapter implements IDEXAdapter with single-hop LB swap logic using LBRouter.swapExactTokensForTokens() and correct Path struct encoding.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create fork tests for TraderJoeLBAdapter</name>
  <files>contracts/test/unit/adapters/TraderJoeLBAdapter.t.sol</files>
  <action>
Create `contracts/test/unit/adapters/TraderJoeLBAdapter.t.sol` with fork tests validating LB swaps against real Arbitrum mainnet pools.

**Test structure pattern** (follow UniswapV3Adapter.t.sol):

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test} from "forge-std/Test.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {TraderJoeLBAdapter} from "../../../src/adapters/TraderJoeLBAdapter.sol";

contract TraderJoeLBAdapterTest is Test {
    TraderJoeLBAdapter public adapter;

    // Arbitrum mainnet addresses
    address constant LB_ROUTER = 0xb4315e873dBcf96Ffd0acd8EA43f689D8c20fB30;
    address constant LB_FACTORY = 0x8e42f2F4101563bF679975178e880FD87d3eFd4e;

    // Token addresses (from existing pool config)
    address constant WETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;
    address constant USDC = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8;
    address constant USDT = 0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9;
    address constant ARB = 0x912CE59144191C1204E64559FE8253a0e49E6548;

    // Known LB pairs (discover via cast or use known addresses)
    // Example: WETH/USDC LB with binStep 15 (0.15%)
    address constant WETH_USDC_LB = address(0); // TODO: discover via LBFactory

    address user = makeAddr("user");

    function setUp() public {
        // Fork Arbitrum mainnet
        vm.createSelectFork(vm.envString("ARBITRUM_MAINNET_RPC_URL"));

        adapter = new TraderJoeLBAdapter(LB_ROUTER);

        // Fund user with tokens
        deal(WETH, user, 100 ether);
        deal(USDC, user, 100_000e6);
    }

    function testSwapSingleHopLB() public {
        // Swap 1 WETH -> USDC on LB pool with binStep 15
        uint256 amountIn = 1 ether;
        uint24 binStep = 15; // 0.15%
        bytes memory extraData = abi.encode(binStep);

        vm.startPrank(user);
        IERC20(WETH).approve(address(adapter), amountIn);

        uint256 balanceBefore = IERC20(USDC).balanceOf(user);
        uint256 amountOut = adapter.swap(WETH, USDC, amountIn, 1, extraData);
        uint256 balanceAfter = IERC20(USDC).balanceOf(user);

        assertGt(amountOut, 0, "Should receive USDC");
        assertEq(balanceAfter - balanceBefore, amountOut, "Balance should match amountOut");
        vm.stopPrank();
    }

    function testSwapRevertsOnZeroAmountIn() public {
        bytes memory extraData = abi.encode(uint24(15));
        vm.startPrank(user);
        IERC20(WETH).approve(address(adapter), 1 ether);

        vm.expectRevert(TraderJoeLBAdapter.ZeroAmountIn.selector);
        adapter.swap(WETH, USDC, 0, 1, extraData);
        vm.stopPrank();
    }

    function testSwapRevertsOnSlippage() public {
        uint256 amountIn = 1 ether;
        uint24 binStep = 15;
        bytes memory extraData = abi.encode(binStep);

        vm.startPrank(user);
        IERC20(WETH).approve(address(adapter), amountIn);

        // Set unrealistic amountOutMin (more than pool can provide)
        uint256 amountOutMin = 1_000_000e6; // 1M USDC (way too high)

        vm.expectRevert();
        adapter.swap(WETH, USDC, amountIn, amountOutMin, extraData);
        vm.stopPrank();
    }

    function testGetAmountOutReturnsZero() public view {
        // LB adapter returns 0 for getAmountOut (off-chain quote signal)
        bytes memory extraData = abi.encode(uint24(15));
        uint256 quote = adapter.getAmountOut(WETH, USDC, 1 ether, extraData);
        assertEq(quote, 0, "LB adapter should return 0 for getAmountOut");
    }
}
```

**Test discovery step** (use cast to find real LB pairs):

```bash
# Discover WETH/USDC LB pair with binStep 15 (0.15%)
cast call $LB_FACTORY "getLBPairInformation(address,address,uint256)" \
  $WETH $USDC 15 --rpc-url $ARBITRUM_MAINNET_RPC_URL
```

If no LB pair exists for WETH/USDC at binStep 15, try:
- WETH/USDC binStep 20 (0.20%)
- WETH/USDT binStep 15 or 20
- ARB/WETH binStep 25 (0.25%)

Update test constants with discovered pair addresses and bin steps.

**Fork requirement:** Tests MUST run with `--fork-url $ARBITRUM_MAINNET_RPC_URL` flag.

**Test coverage:**
1. `testSwapSingleHopLB` - Happy path single-hop swap
2. `testSwapRevertsOnZeroAmountIn` - Zero amount validation
3. `testSwapRevertsOnSlippage` - Slippage protection
4. `testGetAmountOutReturnsZero` - Verify off-chain quote signal

**Do NOT implement multi-hop tests yet** — multi-hop is stubbed in adapter.
  </action>
  <verify>
1. `forge build` compiles test file without errors
2. `forge test --match-path test/unit/adapters/TraderJoeLBAdapter.t.sol --fork-url $ARBITRUM_MAINNET_RPC_URL -vv` passes all tests
3. Test output shows amountOut > 0 for successful swap
4. All 4 test cases pass (single hop, zero amount revert, slippage revert, getAmountOut zero)
  </verify>
  <done>
TraderJoeLBAdapter.t.sol exists with 4+ passing fork tests validating single-hop LB swaps, slippage protection, and off-chain quote signal. Tests run against real Arbitrum mainnet LB pools.
  </done>
</task>

</tasks>

<verification>
1. `forge build` — all contracts compile
2. `forge test --match-path test/unit/adapters/TraderJoeLBAdapter.t.sol --fork-url $ARBITRUM_MAINNET_RPC_URL -vv` — all tests pass
3. TraderJoeLBAdapter implements IDEXAdapter interface
4. Tests demonstrate successful WETH -> USDC swap through real LB pool
5. Adapter uses correct LBRouter.Path struct encoding with binSteps, versions, tokenPath
</verification>

<success_criteria>
On-chain TraderJoeLBAdapter routes swaps through LBRouter V2.1 with correct bin-step path encoding in fork tests. Adapter handles single-hop swaps with proper slippage protection. All fork tests pass against real Arbitrum mainnet LB pools.
</success_criteria>

<output>
After completion, create `.planning/phases/10-trader-joe-lb-adapter/10-01-SUMMARY.md`
</output>
