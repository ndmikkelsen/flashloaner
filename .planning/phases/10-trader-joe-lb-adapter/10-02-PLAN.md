---
phase: 10-trader-joe-lb-adapter
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/src/monitor/types.ts
  - bot/src/monitor/PriceMonitor.ts
  - bot/__tests__/monitor/traderjoe-lb-prices.test.ts
autonomous: true
requirements:
  - DEX-04

must_haves:
  truths:
    - "Bot reads Trader Joe LBPair active bin prices via getActiveId() and converts bin IDs to normalized prices"
    - "PriceMonitor handles 'traderjoe_lb' DEX protocol type distinct from 'uniswap_v3'"
    - "Bin-to-price conversion uses correct fixed-point math: price = (1 + binStep/10000)^(activeId - 2^23)"
  artifacts:
    - path: "bot/src/monitor/types.ts"
      provides: "DEXProtocol union type includes 'traderjoe_lb'"
      contains: "traderjoe_lb"
    - path: "bot/src/monitor/PriceMonitor.ts"
      provides: "LB price reading via getActiveId() and bin-to-price conversion"
      contains: "calculateLBPrice"
      min_lines: 550
    - path: "bot/__tests__/monitor/traderjoe-lb-prices.test.ts"
      provides: "Tests validating LB price reading and bin math"
      min_lines: 80
  key_links:
    - from: "bot/src/monitor/PriceMonitor.ts"
      to: "bot/src/monitor/types.ts"
      via: "import DEXProtocol"
      pattern: "import.*DEXProtocol"
    - from: "bot/__tests__/monitor/traderjoe-lb-prices.test.ts"
      to: "bot/src/monitor/PriceMonitor.ts"
      via: "test price reading"
      pattern: "import.*PriceMonitor"
---

<objective>
Add Trader Joe Liquidity Book price reading to PriceMonitor by fetching active bin IDs from LBPair contracts and converting them to normalized token prices using bin-step-based fixed-point math.

Purpose: Trader Joe LB uses a bin-based pricing model fundamentally different from constant-product (V2) or concentrated liquidity (V3). Instead of reading reserves or sqrtPriceX96, the bot must call LBPair.getActiveId() to get the current active bin ID, then apply the bin-step formula to derive the spot price. This enables the bot to detect arbitrage opportunities between LB pools and other DEXes.

Output: Extended PriceMonitor supporting 'traderjoe_lb' protocol with accurate bin-to-price conversion, validated by tests against real Arbitrum LB pools.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@bot/src/monitor/types.ts
@bot/src/monitor/PriceMonitor.ts
@bot/__tests__/monitor/PriceMonitor.test.ts
@bot/src/config/chains/pools/arbitrum-mainnet.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 'traderjoe_lb' to DEXProtocol type union</name>
  <files>bot/src/monitor/types.ts</files>
  <action>
Update `bot/src/monitor/types.ts` to add "traderjoe_lb" to the DEXProtocol union type.

**Current DEXProtocol type:**
```typescript
export type DEXProtocol = "uniswap_v2" | "uniswap_v3" | "sushiswap" | "sushiswap_v3" | "camelot_v2" | "camelot_v3";
```

**Updated DEXProtocol type:**
```typescript
export type DEXProtocol = "uniswap_v2" | "uniswap_v3" | "sushiswap" | "sushiswap_v3" | "camelot_v2" | "camelot_v3" | "traderjoe_lb";
```

**Rationale:** Trader Joe Liquidity Book is a distinct DEX protocol with unique pricing mechanics (bin-based, not constant-product or concentrated liquidity). It requires separate handling in PriceMonitor for price reading and should not be conflated with other V3-style protocols.

**Do NOT add ramses_v2 yet** — that comes in Phase 9. Only add traderjoe_lb.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes (no type errors)
2. Grep for "traderjoe_lb" in types.ts confirms addition
3. No other files break due to exhaustive type checking
  </verify>
  <done>
DEXProtocol type includes "traderjoe_lb" as a valid protocol. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement LB price reading in PriceMonitor</name>
  <files>bot/src/monitor/PriceMonitor.ts</files>
  <action>
Extend `bot/src/monitor/PriceMonitor.ts` to support Trader Joe Liquidity Book price reading via LBPair.getActiveId() and bin-to-price conversion.

**Changes required:**

**1. Add LBPair ABI constant** (near existing ABIs at top of file):
```typescript
const TRADER_JOE_LB_PAIR_ABI = [
  "function getActiveId() view returns (uint24 activeId)",
];

const lbPairIface = new Interface(TRADER_JOE_LB_PAIR_ABI);
```

**2. Update `getCallDataForPool()` method** to handle traderjoe_lb:
```typescript
private getCallDataForPool(pool: PoolConfig): string {
  if (pool.dex === "traderjoe_lb") {
    return lbPairIface.encodeFunctionData("getActiveId");
  }
  if (pool.dex === "camelot_v3") {
    return algebraIface.encodeFunctionData("globalState");
  }
  // ... existing V3/V2 logic
}
```

**3. Update `decodePriceFromResult()` method** to handle traderjoe_lb:
```typescript
private decodePriceFromResult(pool: PoolConfig, returnData: string): {
  price: number;
  reserves?: [bigint, bigint];
  sqrtPriceX96?: bigint;
  activeId?: number;
} {
  if (pool.dex === "traderjoe_lb") {
    const decoded = lbPairIface.decodeFunctionResult("getActiveId", returnData);
    const activeId = Number(decoded[0]);
    if (!pool.feeTier) {
      throw new Error(`Trader Joe LB pool ${pool.label} missing feeTier (binStep)`);
    }
    return {
      price: this.calculateLBPrice(activeId, pool.feeTier, pool.decimals0, pool.decimals1),
      activeId,
    };
  }
  // ... existing camelot_v3, uniswap_v3, V2 logic
}
```

**4. Update `fetchPrice()` method** to handle traderjoe_lb:
```typescript
async fetchPrice(pool: PoolConfig): Promise<PriceSnapshot> {
  const blockNumber = await this.config.provider.getBlockNumber();

  if (pool.dex === "traderjoe_lb") {
    const data = await this.fetchLBPrice(pool);
    return {
      pool, price: data.price, inversePrice: 1 / data.price,
      blockNumber, timestamp: Date.now(),
      activeId: data.activeId,
    };
  }
  // ... existing camelot_v3, uniswap_v3, V2 logic
}
```

**5. Add `fetchLBPrice()` helper method** (similar to fetchV3Price):
```typescript
/** Read active bin ID from a Trader Joe LB pair */
private async fetchLBPrice(pool: PoolConfig): Promise<{ price: number; activeId: number }> {
  const contract = new Contract(
    pool.poolAddress,
    TRADER_JOE_LB_PAIR_ABI,
    this.config.provider,
  );
  const activeId = await contract.getActiveId();
  const activeIdNum = Number(activeId);

  if (!pool.feeTier) {
    throw new Error(`Trader Joe LB pool ${pool.label} missing feeTier (binStep)`);
  }

  return {
    price: this.calculateLBPrice(activeIdNum, pool.feeTier, pool.decimals0, pool.decimals1),
    activeId: activeIdNum,
  };
}
```

**6. Add `calculateLBPrice()` method** (core bin-to-price conversion):
```typescript
/**
 * Calculate price from Trader Joe LB active bin ID.
 *
 * Formula: price = (1 + binStep/10000)^(activeId - 2^23) * 10^(decimals0 - decimals1)
 *
 * Where:
 * - binStep is the fee tier in basis points (e.g., 25 = 0.25%)
 * - activeId is the current active bin (uint24, centered at 2^23 = 8388608)
 * - 2^23 is the price anchor point (activeId 8388608 = price ratio 1:1)
 *
 * Implementation uses logarithms to avoid overflow:
 * price = exp((activeId - 2^23) * ln(1 + binStep/10000)) * 10^(decimals0 - decimals1)
 */
calculateLBPrice(
  activeId: number,
  binStep: number,
  decimals0: number,
  decimals1: number,
): number {
  const PRICE_ANCHOR = 2 ** 23; // 8388608 (center point where price = 1:1)
  const binStepDecimal = binStep / 10_000; // Convert basis points to decimal
  const exponent = activeId - PRICE_ANCHOR;

  // Compute (1 + binStep/10000)^exponent using logarithms
  // price_ratio = exp(exponent * ln(1 + binStepDecimal))
  const priceRatio = Math.exp(exponent * Math.log(1 + binStepDecimal));

  // Adjust for token decimals
  const decimalAdjustment = 10 ** (decimals0 - decimals1);
  return priceRatio * decimalAdjustment;
}
```

**7. Update PriceSnapshot type** in types.ts to include optional activeId:
```typescript
export interface PriceSnapshot {
  pool: PoolConfig;
  price: number;
  inversePrice: number;
  blockNumber: number;
  timestamp: number;
  reserves?: [bigint, bigint];
  liquidity?: bigint;
  sqrtPriceX96?: bigint;
  activeId?: number; // Trader Joe LB active bin ID
}
```

**Implementation notes:**
- Bin step (feeTier) is stored in basis points (25 = 0.25%, 15 = 0.15%)
- Active bin ID 8388608 (2^23) represents 1:1 price ratio
- activeId > 8388608 means price shifted toward token1 (more token0 per token1)
- activeId < 8388608 means price shifted toward token0 (less token0 per token1)
- Use Math.exp and Math.log for exponentiation (avoids BigInt overflow)

**Error handling:**
- If pool.feeTier (binStep) is undefined for traderjoe_lb pool, throw descriptive error
- Follow existing error patterns (emit "error" event, mark pool stale after retries)
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes (no type errors)
2. `pnpm test -- --run` passes (existing tests unbroken)
3. Grep for "calculateLBPrice" in PriceMonitor.ts confirms method exists
4. Grep for "traderjoe_lb" in PriceMonitor.ts shows 3+ occurrences (getCallDataForPool, decodePriceFromResult, fetchPrice)
5. PriceSnapshot type in types.ts includes optional activeId field
  </verify>
  <done>
PriceMonitor supports traderjoe_lb protocol with LBPair.getActiveId() reading and bin-to-price conversion via calculateLBPrice(). Existing V2/V3 price reading unaffected. All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for Trader Joe LB price reading</name>
  <files>bot/__tests__/monitor/traderjoe-lb-prices.test.ts</files>
  <action>
Create `bot/__tests__/monitor/traderjoe-lb-prices.test.ts` with tests validating LB price reading and bin-to-price conversion logic.

**Test structure:**

```typescript
import { describe, it, expect, beforeAll } from "vitest";
import { JsonRpcProvider } from "ethers";
import { PriceMonitor } from "../../src/monitor/PriceMonitor.js";
import type { PoolConfig } from "../../src/monitor/types.js";

describe("PriceMonitor - Trader Joe LB", () => {
  let provider: JsonRpcProvider;
  let monitor: PriceMonitor;

  // Known Arbitrum LB pool (discover via cast or use known address)
  const WETH_USDC_LB_POOL: PoolConfig = {
    label: "WETH/USDC Trader Joe LB (0.25%)",
    dex: "traderjoe_lb",
    poolAddress: "0x0000000000000000000000000000000000000000", // TODO: discover real pool
    token0: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1", // WETH
    token1: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8", // USDC.e
    decimals0: 18,
    decimals1: 6,
    feeTier: 25, // binStep 25 = 0.25%
  };

  beforeAll(() => {
    const rpcUrl = process.env.ARBITRUM_MAINNET_RPC_URL;
    if (!rpcUrl) {
      throw new Error("ARBITRUM_MAINNET_RPC_URL not set");
    }
    provider = new JsonRpcProvider(rpcUrl);
    monitor = new PriceMonitor({
      provider,
      pools: [WETH_USDC_LB_POOL],
      deltaThresholdPercent: 0.5,
    });
  });

  it("should read active bin ID from LB pool", async () => {
    const snapshot = await monitor.fetchPrice(WETH_USDC_LB_POOL);

    expect(snapshot.activeId).toBeDefined();
    expect(snapshot.activeId).toBeGreaterThan(0);
    expect(snapshot.activeId).toBeLessThan(2 ** 24); // uint24 max
  });

  it("should calculate price from active bin ID", async () => {
    const snapshot = await monitor.fetchPrice(WETH_USDC_LB_POOL);

    expect(snapshot.price).toBeGreaterThan(0);
    expect(snapshot.inversePrice).toBeGreaterThan(0);
    expect(snapshot.price).toBeCloseTo(1 / snapshot.inversePrice, 2);

    // WETH/USDC price should be roughly in 1000-4000 range (1 WETH = ~$2000-$4000)
    expect(snapshot.price).toBeGreaterThan(500);
    expect(snapshot.price).toBeLessThan(10_000);
  });

  it("should calculate correct bin-to-price conversion", () => {
    // Test calculateLBPrice directly with known values
    const PRICE_ANCHOR = 2 ** 23; // 8388608

    // activeId at anchor (1:1 price ratio)
    const priceAt1to1 = monitor.calculateLBPrice(PRICE_ANCHOR, 25, 18, 6);
    expect(priceAt1to1).toBeCloseTo(1, 4); // ~1.0 (adjusted for decimals)

    // activeId above anchor (price shifted toward token1)
    const priceAbove = monitor.calculateLBPrice(PRICE_ANCHOR + 1000, 25, 18, 6);
    expect(priceAbove).toBeGreaterThan(priceAt1to1);

    // activeId below anchor (price shifted toward token0)
    const priceBelow = monitor.calculateLBPrice(PRICE_ANCHOR - 1000, 25, 18, 6);
    expect(priceBelow).toBeLessThan(priceAt1to1);
  });

  it("should emit priceUpdate event with activeId", async () => {
    return new Promise<void>((resolve) => {
      monitor.once("priceUpdate", (snapshot) => {
        expect(snapshot.pool.dex).toBe("traderjoe_lb");
        expect(snapshot.activeId).toBeDefined();
        expect(snapshot.price).toBeGreaterThan(0);
        resolve();
      });

      void monitor.poll();
    });
  });

  it("should throw if LB pool missing feeTier", async () => {
    const invalidPool: PoolConfig = {
      ...WETH_USDC_LB_POOL,
      feeTier: undefined, // Missing binStep
    };

    await expect(monitor.fetchPrice(invalidPool)).rejects.toThrow(/missing feeTier/);
  });
});
```

**Test discovery step** (find real LB pool address):

Use cast to discover WETH/USDC LB pair:
```bash
# Get LB pair info from factory
cast call 0x8e42f2F4101563bF679975178e880FD87d3eFd4e \
  "getLBPairInformation(address,address,uint256)" \
  0x82af49447d8a07e3bd95bd0d56f35241523fbab1 \
  0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8 \
  25 --rpc-url $ARBITRUM_MAINNET_RPC_URL
```

Update `poolAddress` in test with discovered address. If binStep 25 doesn't exist, try 15 or 20.

**Test coverage:**
1. Read active bin ID from real LB pool
2. Calculate price from active bin ID (range check for WETH/USDC)
3. Validate bin-to-price math with known anchor point
4. Emit priceUpdate event with activeId
5. Throw error if feeTier missing

**Run with:** `pnpm test -- --run bot/__tests__/monitor/traderjoe-lb-prices.test.ts`
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` compiles test file
2. `pnpm test -- --run bot/__tests__/monitor/traderjoe-lb-prices.test.ts` passes all tests
3. Test output shows activeId > 0 for real LB pool
4. Price value is in reasonable range for WETH/USDC (500-10000)
5. All 5 test cases pass
  </verify>
  <done>
Test file exists at `bot/__tests__/monitor/traderjoe-lb-prices.test.ts` with 5+ passing tests validating LB price reading, bin-to-price conversion, and activeId extraction from real Arbitrum LB pools.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` — no type errors
2. `pnpm test -- --run` — all existing tests still pass
3. `pnpm test -- --run bot/__tests__/monitor/traderjoe-lb-prices.test.ts` — all LB tests pass
4. DEXProtocol type includes "traderjoe_lb"
5. PriceMonitor.calculateLBPrice() exists and uses correct bin math
6. PriceSnapshot type includes optional activeId field
</verification>

<success_criteria>
Bot reads Trader Joe LBPair active bin prices via getActiveId() and converts bin IDs to normalized token prices using correct fixed-point math. PriceMonitor handles 'traderjoe_lb' as distinct DEX protocol. All tests pass including bin-to-price conversion validation.
</success_criteria>

<output>
After completion, create `.planning/phases/10-trader-joe-lb-adapter/10-02-SUMMARY.md`
</output>
