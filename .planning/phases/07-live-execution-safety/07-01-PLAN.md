---
phase: 07-live-execution-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/src/index.ts
  - bot/src/detector/OpportunityDetector.ts
  - bot/__tests__/integration/shadow-mode.test.ts
autonomous: true
requirements:
  - EXEC-02
  - EXEC-03
  - EXEC-05

must_haves:
  truths:
    - "Shadow mode simulates transactions via eth_call and logs estimated vs simulated profit without broadcasting transactions"
    - "Bot aborts any trade where detection-to-execution latency exceeds 200ms (staleness guard)"
    - "DRY_RUN=true environment variable continues to work exactly as before (backward compatibility)"
  artifacts:
    - path: "bot/src/index.ts"
      provides: "Shadow mode flag handling and staleness detection timestamp capture"
      contains: "SHADOW_MODE"
    - path: "bot/src/detector/OpportunityDetector.ts"
      provides: "Detection timestamp tracking and staleness guard"
      contains: "detectionTimestamp"
    - path: "bot/__tests__/integration/shadow-mode.test.ts"
      provides: "Shadow mode validation tests"
      min_lines: 80
  key_links:
    - from: "bot/src/detector/OpportunityDetector.ts"
      to: "bot/src/detector/types.ts"
      via: "ArbitrageOpportunity type includes detectionTimestamp"
      pattern: "detectionTimestamp.*number"
    - from: "bot/src/index.ts"
      to: "bot/src/engine/ExecutionEngine.ts"
      via: "Shadow mode uses ExecutionEngine.simulateTransaction"
      pattern: "simulateTransaction"
---

<objective>
Implement shadow mode validation and staleness protection to ensure profitability estimates are accurate and trades are fresh before enabling live execution.

Purpose: Shadow mode validates that profit estimation aligns with actual on-chain simulation results (eth_call) without spending gas, building confidence before live trading. Staleness guard prevents executing trades on stale price data when detection-to-execution latency exceeds 200ms.

Output: Shadow mode flag (SHADOW_MODE env var), staleness timestamp tracking, validation logging, and backward-compatible DRY_RUN support.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@bot/src/index.ts
@bot/src/detector/OpportunityDetector.ts
@bot/src/detector/types.ts
@bot/src/engine/ExecutionEngine.ts
@bot/src/builder/TransactionBuilder.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add detection timestamp to ArbitrageOpportunity and staleness guard</name>
  <files>
    bot/src/detector/types.ts
    bot/src/detector/OpportunityDetector.ts
  </files>
  <action>
**In `bot/src/detector/types.ts`:**

The `ArbitrageOpportunity` interface already has a `timestamp` field. No changes needed — this field captures detection time in milliseconds.

**In `bot/src/detector/OpportunityDetector.ts`:**

Add a staleness guard constant and helper method:

1. At the top of the file (after imports), add:
```typescript
/** Maximum allowed detection-to-execution latency in milliseconds */
const MAX_STALENESS_MS = 200;
```

2. Add a public method `checkStaleness` before the `private` methods section:
```typescript
/**
 * Check if an opportunity is too stale to execute.
 *
 * @param opportunity - The opportunity to check
 * @returns { fresh: boolean; latencyMs: number } - Fresh if latency <= 200ms
 */
checkStaleness(opportunity: ArbitrageOpportunity): { fresh: boolean; latencyMs: number } {
  const now = Date.now();
  const latencyMs = now - opportunity.timestamp;
  return {
    fresh: latencyMs <= MAX_STALENESS_MS,
    latencyMs,
  };
}
```

This method will be called by the execution engine before submission to enforce the 200ms staleness limit.

**Do NOT modify the opportunity detection logic** — timestamp is already being set correctly in the `buildOpportunity` method.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes (no type errors)
2. `grep -n "checkStaleness" bot/src/detector/OpportunityDetector.ts` shows the new method
3. `grep -n "MAX_STALENESS_MS = 200" bot/src/detector/OpportunityDetector.ts` shows the constant
  </verify>
  <done>
OpportunityDetector has a `checkStaleness()` method that returns whether an opportunity is fresh (latency <= 200ms) and the actual latency value. The existing `timestamp` field in ArbitrageOpportunity is used for staleness calculation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement shadow mode with eth_call simulation and DRY_RUN backward compatibility</name>
  <files>bot/src/index.ts</files>
  <action>
**Update `FlashloanBot` class to support three modes: DRY_RUN (report-only), SHADOW_MODE (simulate), and LIVE (execute).**

**1. Add mode detection in the constructor:**

After the existing `this.dryRun = dryRun;` line (around line 47), add:

```typescript
// Mode detection: DRY_RUN (backward compatible) -> SHADOW_MODE -> LIVE
const shadowMode = process.env.SHADOW_MODE === "true";
const liveMode = !dryRun && !shadowMode;

this.mode = dryRun ? "dry-run" : shadowMode ? "shadow" : "live";
```

And add a `mode` field to the class:
```typescript
readonly mode: "dry-run" | "shadow" | "live";
```

**2. Import ExecutionEngine and TransactionBuilder:**

Add to the imports at the top:
```typescript
import { ExecutionEngine } from "./engine/ExecutionEngine.js";
import { TransactionBuilder } from "./builder/TransactionBuilder.js";
import type { Wallet } from "ethers";
```

**3. Add optional engine and builder fields:**

After the `detector` field declaration:
```typescript
readonly engine?: ExecutionEngine;
readonly builder?: TransactionBuilder;
```

**4. Initialize engine and builder in SHADOW or LIVE mode:**

In the constructor, after the detector initialization (after line 77), add:

```typescript
// Initialize execution components in SHADOW or LIVE mode
if (this.mode === "shadow" || this.mode === "live") {
  // Builder requires executor address, adapters, flash loan providers
  // For now, we'll initialize these in a future plan when wiring live execution
  // Shadow mode only needs the engine's simulateTransaction capability
  this.engine = undefined; // TODO: Initialize in Plan 03 (live wiring)
  this.builder = undefined; // TODO: Initialize in Plan 03 (live wiring)
}
```

**5. Update `wireEvents()` to handle shadow mode:**

In the `wireEvents()` method, locate the `detector.on("opportunityFound", ...)` handler (around line 186).

Replace it with:

```typescript
this.detector.on("opportunityFound", async (opp) => {
  this.stats.opportunitiesFound++;

  // DRY_RUN mode: just report
  if (this.mode === "dry-run") {
    console.log(formatOpportunityReport(opp, true));
    return;
  }

  // SHADOW mode: simulate via eth_call, log estimated vs simulated
  if (this.mode === "shadow") {
    console.log(formatOpportunityReport(opp, true));

    // TODO: In Plan 03, add actual eth_call simulation here
    // For now, just log that shadow mode is active
    this.log("info", `[SHADOW] Would simulate opportunity ${opp.id} via eth_call`);
    this.log("info", `[SHADOW] Estimated profit: ${opp.netProfit.toFixed(8)} ETH`);
    return;
  }

  // LIVE mode: check staleness and execute
  if (this.mode === "live") {
    const staleness = this.detector.checkStaleness(opp);
    if (!staleness.fresh) {
      this.log("warn", `[STALE] Opportunity ${opp.id} is too stale (${staleness.latencyMs}ms > 200ms). Aborting.`);
      return;
    }

    console.log(formatOpportunityReport(opp, false));
    this.log("info", `[LIVE] Latency: ${staleness.latencyMs}ms (fresh)`);

    // TODO: In Plan 03, add actual transaction submission here
    this.log("info", `[LIVE] Would submit transaction for ${opp.id}`);
  }
});
```

**6. Update the `start()` method log to show mode:**

In the `start()` method, replace the existing `Dry-run mode: ${this.dryRun}` log line with:

```typescript
this.log("info", `Mode: ${this.mode.toUpperCase()}`);
```

**7. Update the static `fromEnv()` method:**

The `fromEnv()` method currently accepts a `dryRun` parameter. Keep this for backward compatibility, but also check the `DRY_RUN` environment variable:

```typescript
static fromEnv(overrides: Partial<BotConfig> = {}, dryRun?: boolean): FlashloanBot {
  const envVars = parseEnv(process.env);
  const pools = overrides.pools ?? MAINNET_POOLS;
  const config = buildConfig(envVars, { ...overrides, pools });

  // Backward compatibility: DRY_RUN env var or explicit parameter
  const isDryRun = dryRun ?? (process.env.DRY_RUN !== "false");

  return new FlashloanBot(config, isDryRun);
}
```

**Why async opportunityFound handler:** We need to await the engine's `simulateTransaction()` call in Plan 03. Making it async now prepares for that.

**Backward compatibility check:** DRY_RUN=true (or unset) still produces the same dry-run output as before. SHADOW_MODE=true enables shadow mode. Both false enables live mode (which will be wired in Plan 03).
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes (no type errors)
2. `grep -n "mode:" bot/src/index.ts` shows the new mode field
3. `grep -n "SHADOW" bot/src/index.ts` shows shadow mode handling
4. `grep -n "checkStaleness" bot/src/index.ts` shows staleness guard in live mode
5. Run `DRY_RUN=true pnpm run bot:arb-mainnet` for 10 seconds and verify output is unchanged (backward compatibility)
  </verify>
  <done>
FlashloanBot supports three modes (dry-run, shadow, live) controlled by DRY_RUN and SHADOW_MODE env vars. Shadow mode logs simulation intent. Live mode enforces 200ms staleness guard before execution. DRY_RUN backward compatibility is preserved.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add shadow mode integration tests</name>
  <files>bot/__tests__/integration/shadow-mode.test.ts</files>
  <action>
Create a new test file `bot/__tests__/integration/shadow-mode.test.ts` that validates shadow mode and staleness guard behavior.

**Test file structure:**

```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { FlashloanBot } from "../../src/index.js";
import { OpportunityDetector } from "../../src/detector/OpportunityDetector.js";
import type { ArbitrageOpportunity } from "../../src/detector/types.js";
import type { BotConfig } from "../../src/config/types.js";

describe("Shadow Mode & Staleness Guard", () => {
  let mockConfig: BotConfig;

  beforeEach(() => {
    mockConfig = {
      network: { rpcUrl: "http://localhost:8545", chainId: 42161 },
      pools: [],
      monitor: {
        deltaThresholdPercent: 0.5,
        pollIntervalMs: 5000,
        maxRetries: 3,
        minReserveWeth: 10,
        wethAddress: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
      },
      detector: {
        minProfitThreshold: 0.01,
        maxSlippage: 0.005,
        defaultInputAmount: 10,
        gasPriceGwei: 0.1,
        gasPerSwap: 150000,
      },
      logLevel: "info",
    };
  });

  describe("Mode Detection", () => {
    it("should default to dry-run mode when no env vars set", () => {
      const bot = new FlashloanBot(mockConfig, true);
      expect(bot.mode).toBe("dry-run");
    });

    it("should use shadow mode when SHADOW_MODE=true", () => {
      process.env.SHADOW_MODE = "true";
      const bot = new FlashloanBot(mockConfig, false);
      expect(bot.mode).toBe("shadow");
      delete process.env.SHADOW_MODE;
    });

    it("should use live mode when both DRY_RUN and SHADOW_MODE are false", () => {
      process.env.SHADOW_MODE = "false";
      const bot = new FlashloanBot(mockConfig, false);
      expect(bot.mode).toBe("live");
      delete process.env.SHADOW_MODE;
    });
  });

  describe("Staleness Guard", () => {
    it("should detect fresh opportunities (latency < 200ms)", () => {
      const detector = new OpportunityDetector({
        minProfitThreshold: 0.01,
        defaultInputAmount: 10,
      });

      const freshOpp: ArbitrageOpportunity = {
        id: "test-fresh",
        path: {
          steps: [],
          baseToken: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
          label: "Test path",
        },
        inputAmount: 10,
        grossProfit: 0.05,
        costs: {
          flashLoanFee: 0.005,
          gasCost: 0.01,
          slippageCost: 0.001,
          totalCost: 0.016,
        },
        netProfit: 0.034,
        netProfitPercent: 0.34,
        priceDelta: {
          pair: "WETH/USDC",
          poolA: {} as any,
          poolB: {} as any,
          deltaPercent: 1.2,
          blockNumber: 12345,
        },
        blockNumber: 12345,
        timestamp: Date.now(), // Fresh timestamp
      };

      const result = detector.checkStaleness(freshOpp);
      expect(result.fresh).toBe(true);
      expect(result.latencyMs).toBeLessThan(200);
    });

    it("should detect stale opportunities (latency > 200ms)", () => {
      const detector = new OpportunityDetector({
        minProfitThreshold: 0.01,
        defaultInputAmount: 10,
      });

      const staleOpp: ArbitrageOpportunity = {
        id: "test-stale",
        path: {
          steps: [],
          baseToken: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
          label: "Test path",
        },
        inputAmount: 10,
        grossProfit: 0.05,
        costs: {
          flashLoanFee: 0.005,
          gasCost: 0.01,
          slippageCost: 0.001,
          totalCost: 0.016,
        },
        netProfit: 0.034,
        netProfitPercent: 0.34,
        priceDelta: {
          pair: "WETH/USDC",
          poolA: {} as any,
          poolB: {} as any,
          deltaPercent: 1.2,
          blockNumber: 12345,
        },
        blockNumber: 12345,
        timestamp: Date.now() - 500, // 500ms ago (stale)
      };

      const result = detector.checkStaleness(staleOpp);
      expect(result.fresh).toBe(false);
      expect(result.latencyMs).toBeGreaterThanOrEqual(500);
    });

    it("should use 200ms threshold exactly", () => {
      const detector = new OpportunityDetector({
        minProfitThreshold: 0.01,
        defaultInputAmount: 10,
      });

      const edgeOpp: ArbitrageOpportunity = {
        id: "test-edge",
        path: {
          steps: [],
          baseToken: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
          label: "Test path",
        },
        inputAmount: 10,
        grossProfit: 0.05,
        costs: {
          flashLoanFee: 0.005,
          gasCost: 0.01,
          slippageCost: 0.001,
          totalCost: 0.016,
        },
        netProfit: 0.034,
        netProfitPercent: 0.34,
        priceDelta: {
          pair: "WETH/USDC",
          poolA: {} as any,
          poolB: {} as any,
          deltaPercent: 1.2,
          blockNumber: 12345,
        },
        blockNumber: 12345,
        timestamp: Date.now() - 200, // Exactly 200ms ago
      };

      const result = detector.checkStaleness(edgeOpp);
      // At exactly 200ms, it should still be fresh (<=)
      expect(result.fresh).toBe(true);
      expect(result.latencyMs).toBeGreaterThanOrEqual(200);
    });
  });

  describe("Backward Compatibility", () => {
    it("should preserve DRY_RUN=true behavior", () => {
      process.env.DRY_RUN = "true";
      const bot = FlashloanBot.fromEnv();
      expect(bot.mode).toBe("dry-run");
      expect(bot.dryRun).toBe(true);
      delete process.env.DRY_RUN;
    });

    it("should default to dry-run when DRY_RUN is unset", () => {
      delete process.env.DRY_RUN;
      const bot = FlashloanBot.fromEnv();
      expect(bot.mode).toBe("dry-run");
      expect(bot.dryRun).toBe(true);
    });
  });
});
```

**Coverage goals:**
1. Mode detection (dry-run, shadow, live)
2. Staleness guard (fresh < 200ms, stale > 200ms, edge case = 200ms)
3. Backward compatibility (DRY_RUN=true still works)

All tests should pass without actually connecting to a chain (unit tests, no integration with real provider).
  </action>
  <verify>
`pnpm test -- --run bot/__tests__/integration/shadow-mode.test.ts` passes with all tests green (minimum 7 test cases).
  </verify>
  <done>
Shadow mode integration test file exists with passing tests for mode detection, staleness guard (fresh/stale/edge cases), and DRY_RUN backward compatibility.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` — no type errors
2. `pnpm test -- --run bot/__tests__/integration/shadow-mode.test.ts` — all shadow mode tests pass
3. `pnpm test` — all existing tests still pass (no regressions)
4. `DRY_RUN=true pnpm run bot:arb-mainnet` runs for 10 seconds and produces same output as before (backward compatibility)
5. `grep -n "checkStaleness" bot/src/detector/OpportunityDetector.ts` shows the staleness guard method
6. `grep -n "mode:" bot/src/index.ts` shows mode field in FlashloanBot class
7. `grep -n "SHADOW" bot/src/index.ts` shows shadow mode handling in wireEvents
</verification>

<success_criteria>
Shadow mode flag exists and logs simulation intent without broadcasting. Staleness guard aborts trades with >200ms latency. DRY_RUN=true continues to work exactly as before. All tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/07-live-execution-safety/07-01-SUMMARY.md`
</output>
