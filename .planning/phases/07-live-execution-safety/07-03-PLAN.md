---
phase: 07-live-execution-safety
plan: 03
type: execute
wave: 2
depends_on:
  - 07-01
  - 07-02
files_modified:
  - bot/src/index.ts
  - bot/src/run-arb-mainnet.ts
  - bot/__tests__/integration/live-execution.test.ts
  - .env.arbitrum-mainnet
autonomous: true
requirements:
  - EXEC-01

must_haves:
  truths:
    - "In live mode (DRY_RUN=false, SHADOW_MODE=false), bot submits real transactions via ExecutionEngine when profitable opportunities are detected"
    - "Transactions appear on-chain at Arbiscan after submission"
    - "Shadow mode uses ExecutionEngine.simulateTransaction (eth_call) to validate profit estimates without broadcasting"
    - "Nonce manager prevents nonce collisions after crashes by persisting state to disk"
  artifacts:
    - path: "bot/src/index.ts"
      provides: "Live execution wiring with ExecutionEngine, TransactionBuilder, and NonceManager"
      contains: "ExecutionEngine"
    - path: "bot/src/run-arb-mainnet.ts"
      provides: "Updated mainnet entry point with live execution support"
      contains: "SHADOW_MODE"
    - path: "bot/__tests__/integration/live-execution.test.ts"
      provides: "Live execution integration tests (fork-based)"
      min_lines: 60
    - path: ".env.arbitrum-mainnet"
      provides: "Environment variable documentation for live execution modes"
      contains: "SHADOW_MODE"
  key_links:
    - from: "bot/src/index.ts"
      to: "bot/src/engine/ExecutionEngine.ts"
      via: "FlashloanBot instantiates ExecutionEngine in shadow/live mode"
      pattern: "new ExecutionEngine"
    - from: "bot/src/index.ts"
      to: "bot/src/builder/TransactionBuilder.ts"
      via: "FlashloanBot instantiates TransactionBuilder for encoding transactions"
      pattern: "new TransactionBuilder"
    - from: "bot/src/index.ts"
      to: "bot/src/nonce/NonceManager.ts"
      via: "FlashloanBot uses NonceManager for crash-safe nonce handling"
      pattern: "new NonceManager"
---

<objective>
Wire ExecutionEngine, TransactionBuilder, and NonceManager into FlashloanBot to enable real transaction submission in live mode, with shadow mode validation and crash-safe nonce management.

Purpose: Plans 01 and 02 built the components (shadow mode flag, staleness guard, nonce manager). This plan connects them all together, enabling the bot to submit real arbitrage transactions to Arbitrum mainnet when live mode is enabled. Shadow mode validates profit estimates via eth_call before enabling live trading.

Output: Fully-wired live execution in FlashloanBot, updated run-arb-mainnet.ts entry point, integration tests, and environment variable documentation.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/07-live-execution-safety/07-01-PLAN.md
@.planning/phases/07-live-execution-safety/07-02-PLAN.md

@bot/src/index.ts
@bot/src/run-arb-mainnet.ts
@bot/src/engine/ExecutionEngine.ts
@bot/src/builder/TransactionBuilder.ts
@bot/src/nonce/NonceManager.ts
@bot/src/gas/ArbitrumGasEstimator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire ExecutionEngine, TransactionBuilder, and NonceManager into FlashloanBot</name>
  <files>bot/src/index.ts</files>
  <action>
**Update FlashloanBot to instantiate and use execution components in shadow/live modes.**

**1. Add imports at the top:**

```typescript
import { ExecutionEngine } from "./engine/ExecutionEngine.js";
import { TransactionBuilder } from "./builder/TransactionBuilder.js";
import { NonceManager } from "./nonce/NonceManager.js";
import type { Wallet } from "ethers";
```

**2. Update BotConfig type to include execution config:**

The `BotConfig` type is imported from `./config/index.js`. We'll need to add optional execution config fields. For now, we'll accept them as constructor parameters.

Add to the FlashloanBot constructor signature (around line 45):

```typescript
constructor(
  config: BotConfig,
  dryRun = true,
  executionConfig?: {
    wallet?: Wallet;
    executorAddress?: string;
    adapters?: Record<string, string>;
    flashLoanProviders?: { aave_v3: string; balancer: string };
  }
)
```

**3. Initialize execution components in shadow/live modes:**

Replace the TODO comment in the constructor (the one added in Plan 01) with actual initialization:

```typescript
// Initialize execution components in SHADOW or LIVE mode
if (this.mode === "shadow" || this.mode === "live") {
  if (!executionConfig?.wallet) {
    throw new Error("Wallet is required for shadow/live mode");
  }

  if (!executionConfig?.executorAddress) {
    throw new Error("Executor address is required for shadow/live mode");
  }

  if (!executionConfig?.adapters) {
    throw new Error("Adapters config is required for shadow/live mode");
  }

  if (!executionConfig?.flashLoanProviders) {
    throw new Error("Flash loan providers config is required for shadow/live mode");
  }

  this.builder = new TransactionBuilder({
    executorAddress: executionConfig.executorAddress,
    adapters: executionConfig.adapters,
    flashLoanProviders: executionConfig.flashLoanProviders,
    chainId: config.network.chainId,
  });

  this.engine = new ExecutionEngine(executionConfig.wallet, {
    confirmations: 1,
    confirmationTimeoutMs: 120_000,
    maxConsecutiveFailures: 5,
    dryRun: this.mode === "shadow", // Shadow mode uses engine in dry-run
  });

  this.nonceManager = new NonceManager({
    provider: new JsonRpcProvider(config.network.rpcUrl),
    address: executionConfig.wallet.address,
    statePath: ".data/nonce.json",
    pendingTimeoutMs: 300_000, // 5 minutes
  });

  // Sync nonce manager with on-chain state
  void this.nonceManager.syncWithOnChain();
}
```

**4. Add nonceManager field declaration:**

After the `engine` and `builder` field declarations:

```typescript
readonly nonceManager?: NonceManager;
```

**5. Complete the shadow mode implementation in wireEvents:**

Replace the TODO comments in the `opportunityFound` handler's shadow mode section:

```typescript
// SHADOW mode: simulate via eth_call, log estimated vs simulated
if (this.mode === "shadow") {
  console.log(formatOpportunityReport(opp, true));

  if (!this.builder || !this.engine) {
    this.log("error", "[SHADOW] Builder or engine not initialized");
    return;
  }

  // Build the transaction
  const tx = this.builder.buildArbitrageTransaction(opp, "aave_v3");

  // Simulate via eth_call (free, no gas cost)
  const simResult = await this.engine.simulateTransaction({
    ...tx,
    gas: { maxFeePerGas: 0n, maxPriorityFeePerGas: 0n, gasLimit: 500_000n },
    nonce: 0,
  });

  if (simResult.success) {
    this.log("info", `[SHADOW] ✓ Simulation succeeded for ${opp.id}`);
    this.log("info", `[SHADOW] Estimated profit: ${opp.netProfit.toFixed(8)} ETH`);
    this.log("info", `[SHADOW] Would broadcast in live mode`);
  } else {
    this.log("warn", `[SHADOW] ✗ Simulation failed: ${simResult.reason}`);
    this.log("warn", `[SHADOW] Estimated profit was ${opp.netProfit.toFixed(8)} ETH, but would revert on-chain`);
  }
  return;
}
```

**6. Complete the live mode implementation:**

Replace the TODO comment in the live mode section:

```typescript
// LIVE mode: check staleness and execute
if (this.mode === "live") {
  const staleness = this.detector.checkStaleness(opp);
  if (!staleness.fresh) {
    this.log("warn", `[STALE] Opportunity ${opp.id} is too stale (${staleness.latencyMs}ms > 200ms). Aborting.`);
    return;
  }

  console.log(formatOpportunityReport(opp, false));
  this.log("info", `[LIVE] Latency: ${staleness.latencyMs}ms (fresh)`);

  if (!this.builder || !this.engine || !this.nonceManager) {
    this.log("error", "[LIVE] Builder, engine, or nonce manager not initialized");
    return;
  }

  try {
    // Get next nonce (waits for pending transactions if any)
    const nonceResult = await this.nonceManager.getNextNonce();
    if (nonceResult.hadPending) {
      this.log("info", `[LIVE] Resolved pending transaction (status: ${nonceResult.pendingStatus})`);
    }

    // Build transaction
    const tx = this.builder.buildArbitrageTransaction(opp, "aave_v3");

    // Get current gas parameters from provider
    const provider = new JsonRpcProvider(this.config.network.rpcUrl);
    const feeData = await provider.getFeeData();
    const baseFeeGwei = Number(feeData.gasPrice ?? 0n) / 1e9;
    const priorityFeeGwei = 0.01; // 0.01 gwei tip on Arbitrum

    // Calculate gas settings
    const gasSettings = this.builder.calculateGasSettings(
      baseFeeGwei,
      priorityFeeGwei,
      500_000, // Conservative gas limit
    );

    // Prepare transaction with gas and nonce
    const preparedTx = this.builder.prepareTransaction(tx, gasSettings, nonceResult.nonce);

    // Mark nonce as submitted BEFORE sending (crash-safe)
    // We don't have the txHash yet, but we'll update it after submission
    // For now, we'll mark it in the engine's submission event handler

    // Submit transaction
    this.log("info", `[LIVE] Submitting transaction for ${opp.id}...`);
    const result = await this.engine.executeTransaction(preparedTx);

    if (result.status === "confirmed") {
      this.log("info", `[LIVE] ✓ Transaction confirmed: ${result.txHash}`);
      this.log("info", `[LIVE] Gas used: ${result.gasUsed?.toString() ?? "unknown"}`);
      this.nonceManager.markConfirmed(result.txHash!);
    } else if (result.status === "reverted") {
      this.log("warn", `[LIVE] ✗ Transaction reverted: ${result.txHash}`);
      this.log("warn", `[LIVE] Revert reason: ${result.revertReason ?? "unknown"}`);
      this.nonceManager.markConfirmed(result.txHash!); // Still increment nonce
    } else {
      this.log("error", `[LIVE] ✗ Transaction failed: ${result.error}`);
    }
  } catch (err) {
    this.log("error", `[LIVE] Execution error: ${err instanceof Error ? err.message : String(err)}`);
  }
}
```

**7. Wire up engine events to track nonce on submission:**

In the constructor, after initializing the engine (inside the shadow/live block), add:

```typescript
// Track nonce on transaction submission
this.engine.on("submitted", (txHash, tx) => {
  if (this.nonceManager) {
    this.nonceManager.markSubmitted(txHash);
  }
});
```

**Why mark nonce before submission:** We want to persist the nonce BEFORE sending the transaction to ensure crash safety. However, we don't have the txHash until after submission. The current implementation marks the nonce in the "submitted" event handler, which is good enough for crash safety (the state is persisted immediately after the transaction is broadcast).

**Alternative approach (more crash-safe):** We could mark the nonce with a placeholder txHash before submission, then update it after. For this plan, the event-based approach is simpler and sufficient.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes (no type errors)
2. `grep -n "new ExecutionEngine" bot/src/index.ts` shows engine initialization
3. `grep -n "new TransactionBuilder" bot/src/index.ts` shows builder initialization
4. `grep -n "new NonceManager" bot/src/index.ts` shows nonce manager initialization
5. `grep -n "executeTransaction" bot/src/index.ts` shows live execution call
6. `grep -n "simulateTransaction" bot/src/index.ts` shows shadow mode simulation
  </verify>
  <done>
FlashloanBot has ExecutionEngine, TransactionBuilder, and NonceManager wired in shadow/live modes. Shadow mode simulates transactions via eth_call and logs results. Live mode enforces staleness guard, acquires crash-safe nonces, builds transactions, and submits them via ExecutionEngine. Nonce is marked on submission and confirmed after execution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update run-arb-mainnet.ts to support live execution modes</name>
  <files>
    bot/src/run-arb-mainnet.ts
    .env.arbitrum-mainnet
  </files>
  <action>
**Update `bot/src/run-arb-mainnet.ts` to instantiate FlashloanBot with execution config in shadow/live modes.**

**1. Add imports:**

At the top, add:
```typescript
import { Wallet } from "ethers";
import { loadChainConfig } from "./config/index.js";
```

(Note: `loadChainConfig` is already imported, so just add `Wallet`.)

**2. Detect execution mode:**

After the `main()` function starts (around line 65), add:

```typescript
// Execution mode detection
const dryRun = process.env.DRY_RUN !== "false";
const shadowMode = process.env.SHADOW_MODE === "true";
const liveMode = !dryRun && !shadowMode;

const mode = dryRun ? "DRY-RUN" : shadowMode ? "SHADOW" : "LIVE";
```

**3. Update the header log:**

Change the header to show the mode:
```typescript
console.log(c.cyan(`\n========================================`));
console.log(c.cyan(`  Flashloan Bot v${BOT_VERSION} — ARBITRUM ONE`));
console.log(c.cyan(`  Mode:     ${mode}`));
console.log(c.cyan(`  Chain:    ${chain.chainName} (chainId ${chain.chainId})`));
console.log(c.cyan(`  RPC:      ${rpcStatus}`));
console.log(c.cyan(`  Pools:    ${chain.pools.length} configured`));
console.log(c.cyan(`  WETH:     ${chain.tokens.WETH}`));
console.log(c.cyan(`  Input:    ${chain.detector.defaultInputAmount} ETH`));
console.log(c.cyan(`========================================\n`));
```

**4. Load wallet and execution config in shadow/live modes:**

After the RPC URL guard (around line 87), add:

```typescript
// Load wallet in shadow/live modes
let wallet: Wallet | undefined;
if (shadowMode || liveMode) {
  const privateKey = process.env.PRIVATE_KEY;
  if (!privateKey) {
    console.error(`[ERROR] PRIVATE_KEY environment variable is required for ${mode} mode.`);
    console.error(`[ERROR] Set PRIVATE_KEY to your wallet's private key (0x...)`);
    process.exit(1);
  }

  const provider = new JsonRpcProvider(chain.rpcUrl);
  wallet = new Wallet(privateKey, provider);

  console.log(c.cyan(`  Wallet:   ${wallet.address}`));
  console.log(c.cyan(`  Balance:  (checking...)`));

  const balance = await provider.getBalance(wallet.address);
  const balanceEth = Number(balance) / 1e18;
  console.log(c.cyan(`            ${balanceEth.toFixed(6)} ETH\n`));

  if (balanceEth < 0.01) {
    console.warn(c.yellow(`[WARN] Low wallet balance (${balanceEth.toFixed(6)} ETH). Ensure you have enough ETH for gas.`));
  }
}

// Execution config (adapters, executor address, flash loan providers)
const executionConfig = (shadowMode || liveMode) && wallet ? {
  wallet,
  executorAddress: process.env.EXECUTOR_ADDRESS ?? "0x0000000000000000000000000000000000000000", // TODO: Set in .env
  adapters: {
    uniswap_v2: process.env.ADAPTER_UNISWAP_V2 ?? "0x0000000000000000000000000000000000000000",
    uniswap_v3: process.env.ADAPTER_UNISWAP_V3 ?? "0x0000000000000000000000000000000000000000",
    sushiswap: process.env.ADAPTER_SUSHISWAP ?? "0x0000000000000000000000000000000000000000",
  },
  flashLoanProviders: {
    aave_v3: chain.protocols.aaveV3Pool,
    balancer: chain.protocols.balancerVault,
  },
} : undefined;
```

**5. Pass execution config to FlashloanBot:**

Replace the FlashloanBot instantiation (around line 91) with:

```typescript
const bot = new FlashloanBot(
  {
    network: { rpcUrl: chain.rpcUrl, chainId: chain.chainId },
    pools: chain.pools,
    monitor: chain.monitor,
    detector: chain.detector,
    logLevel: (process.env.LOG_LEVEL as "debug" | "info" | "warn" | "error") ?? "debug",
  },
  dryRun,
  executionConfig,
);
```

**6. Document environment variables in `.env.arbitrum-mainnet`:**

Add to the top of the file:

```bash
# Execution Modes
# DRY_RUN=true          - Report opportunities without submitting transactions (default)
# SHADOW_MODE=true      - Simulate transactions via eth_call to validate profit estimates
# DRY_RUN=false         - Enable live transaction submission (requires PRIVATE_KEY)

# Wallet (required for SHADOW_MODE or live mode)
# PRIVATE_KEY=0x...     - Private key for transaction signing (NEVER commit this!)

# Contract Addresses (required for SHADOW_MODE or live mode)
# EXECUTOR_ADDRESS=0x...              - FlashloanExecutor contract address
# ADAPTER_UNISWAP_V2=0x...            - UniswapV2Adapter contract address
# ADAPTER_UNISWAP_V3=0x...            - UniswapV3Adapter contract address
# ADAPTER_SUSHISWAP=0x...             - SushiSwapAdapter contract address

# RPC Configuration
RPC_URL=https://arb1.arbitrum.io/rpc

# Logging
LOG_LEVEL=debug
```

**Important:** The EXECUTOR_ADDRESS and ADAPTER_* addresses will be set when contracts are deployed (Phase 2 already deployed them, so these should be real addresses). For now, we'll leave them as placeholders and add a TODO comment in the code.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes (no type errors)
2. `grep -n "SHADOW_MODE" bot/src/run-arb-mainnet.ts` shows mode detection
3. `grep -n "PRIVATE_KEY" bot/src/run-arb-mainnet.ts` shows wallet loading
4. `grep -n "executionConfig" bot/src/run-arb-mainnet.ts` shows config passing to FlashloanBot
5. `cat .env.arbitrum-mainnet` shows mode documentation
  </verify>
  <done>
run-arb-mainnet.ts detects execution mode (dry-run, shadow, live), loads wallet in shadow/live modes, constructs execution config with adapters and executor address, and passes it to FlashloanBot. .env.arbitrum-mainnet documents all mode-related environment variables.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add live execution integration tests</name>
  <files>bot/__tests__/integration/live-execution.test.ts</files>
  <action>
Create a new integration test file `bot/__tests__/integration/live-execution.test.ts` that validates live execution wiring using a local fork.

**Test structure:**

```typescript
import { describe, it, expect, beforeAll } from "vitest";
import { JsonRpcProvider, Wallet } from "ethers";
import { FlashloanBot } from "../../src/index.js";
import type { BotConfig } from "../../src/config/types.js";

/**
 * Live execution integration tests.
 *
 * These tests use a local Arbitrum fork to validate that the bot can:
 * - Instantiate ExecutionEngine, TransactionBuilder, NonceManager in shadow/live modes
 * - Simulate transactions via eth_call in shadow mode
 * - Submit transactions in live mode (on fork)
 *
 * NOTE: These tests require a local Arbitrum fork running on http://localhost:8545
 * To run: anvil --fork-url https://arb1.arbitrum.io/rpc --chain-id 42161
 */
describe("Live Execution Integration (Fork)", () => {
  const FORK_RPC = process.env.FORK_RPC_URL ?? "http://localhost:8545";
  const TEST_PRIVATE_KEY = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"; // Anvil default key #0

  let provider: JsonRpcProvider;
  let wallet: Wallet;

  beforeAll(async () => {
    provider = new JsonRpcProvider(FORK_RPC);
    wallet = new Wallet(TEST_PRIVATE_KEY, provider);

    // Verify fork is running
    try {
      await provider.getBlockNumber();
    } catch (err) {
      console.warn("Fork not available, skipping live execution tests");
      return;
    }
  });

  describe("Shadow Mode", () => {
    it("should instantiate bot with ExecutionEngine in shadow mode", async () => {
      const config: BotConfig = {
        network: { rpcUrl: FORK_RPC, chainId: 42161 },
        pools: [],
        monitor: {
          deltaThresholdPercent: 0.5,
          pollIntervalMs: 5000,
          maxRetries: 3,
          minReserveWeth: 10,
          wethAddress: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
        },
        detector: {
          minProfitThreshold: 0.01,
          maxSlippage: 0.005,
          defaultInputAmount: 10,
          gasPriceGwei: 0.1,
          gasPerSwap: 150000,
        },
        logLevel: "info",
      };

      const executionConfig = {
        wallet,
        executorAddress: "0x0000000000000000000000000000000000000001", // Dummy for test
        adapters: {
          uniswap_v2: "0x0000000000000000000000000000000000000002",
          uniswap_v3: "0x0000000000000000000000000000000000000003",
          sushiswap: "0x0000000000000000000000000000000000000004",
        },
        flashLoanProviders: {
          aave_v3: "0x794a61358D6845594F94dc1DB02A252b5b4814aD",
          balancer: "0xBA12222222228d8Ba445958a75a0704d566BF2C8",
        },
      };

      // Shadow mode: DRY_RUN=false, SHADOW_MODE=true
      process.env.DRY_RUN = "false";
      process.env.SHADOW_MODE = "true";

      const bot = new FlashloanBot(config, false, executionConfig);

      expect(bot.mode).toBe("shadow");
      expect(bot.engine).toBeDefined();
      expect(bot.builder).toBeDefined();
      expect(bot.nonceManager).toBeDefined();

      delete process.env.DRY_RUN;
      delete process.env.SHADOW_MODE;
    });
  });

  describe("Live Mode", () => {
    it("should instantiate bot with ExecutionEngine in live mode", async () => {
      const config: BotConfig = {
        network: { rpcUrl: FORK_RPC, chainId: 42161 },
        pools: [],
        monitor: {
          deltaThresholdPercent: 0.5,
          pollIntervalMs: 5000,
          maxRetries: 3,
          minReserveWeth: 10,
          wethAddress: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
        },
        detector: {
          minProfitThreshold: 0.01,
          maxSlippage: 0.005,
          defaultInputAmount: 10,
          gasPriceGwei: 0.1,
          gasPerSwap: 150000,
        },
        logLevel: "info",
      };

      const executionConfig = {
        wallet,
        executorAddress: "0x0000000000000000000000000000000000000001",
        adapters: {
          uniswap_v2: "0x0000000000000000000000000000000000000002",
          uniswap_v3: "0x0000000000000000000000000000000000000003",
          sushiswap: "0x0000000000000000000000000000000000000004",
        },
        flashLoanProviders: {
          aave_v3: "0x794a61358D6845594F94dc1DB02A252b5b4814aD",
          balancer: "0xBA12222222228d8Ba445958a75a0704d566BF2C8",
        },
      };

      // Live mode: DRY_RUN=false, SHADOW_MODE=false
      process.env.DRY_RUN = "false";
      process.env.SHADOW_MODE = "false";

      const bot = new FlashloanBot(config, false, executionConfig);

      expect(bot.mode).toBe("live");
      expect(bot.engine).toBeDefined();
      expect(bot.builder).toBeDefined();
      expect(bot.nonceManager).toBeDefined();

      delete process.env.DRY_RUN;
      delete process.env.SHADOW_MODE;
    });

    it("should sync nonce manager with on-chain nonce on initialization", async () => {
      const config: BotConfig = {
        network: { rpcUrl: FORK_RPC, chainId: 42161 },
        pools: [],
        monitor: {
          deltaThresholdPercent: 0.5,
          pollIntervalMs: 5000,
          maxRetries: 3,
          minReserveWeth: 10,
          wethAddress: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
        },
        detector: {
          minProfitThreshold: 0.01,
          maxSlippage: 0.005,
          defaultInputAmount: 10,
          gasPriceGwei: 0.1,
          gasPerSwap: 150000,
        },
        logLevel: "info",
      };

      const executionConfig = {
        wallet,
        executorAddress: "0x0000000000000000000000000000000000000001",
        adapters: {
          uniswap_v2: "0x0000000000000000000000000000000000000002",
          uniswap_v3: "0x0000000000000000000000000000000000000003",
          sushiswap: "0x0000000000000000000000000000000000000004",
        },
        flashLoanProviders: {
          aave_v3: "0x794a61358D6845594F94dc1DB02A252b5b4814aD",
          balancer: "0xBA12222222228d8Ba445958a75a0704d566BF2C8",
        },
      };

      process.env.DRY_RUN = "false";
      process.env.SHADOW_MODE = "false";

      const bot = new FlashloanBot(config, false, executionConfig);

      // Wait for nonce sync (async in constructor via void)
      await new Promise((resolve) => setTimeout(resolve, 100));

      expect(bot.nonceManager).toBeDefined();
      const state = bot.nonceManager!.getState();
      expect(state.address).toBe(wallet.address.toLowerCase());
      expect(state.nonce).toBeGreaterThanOrEqual(0);

      delete process.env.DRY_RUN;
      delete process.env.SHADOW_MODE;
    });
  });

  describe("Error Handling", () => {
    it("should throw error if wallet is missing in shadow mode", () => {
      const config: BotConfig = {
        network: { rpcUrl: FORK_RPC, chainId: 42161 },
        pools: [],
        monitor: {
          deltaThresholdPercent: 0.5,
          pollIntervalMs: 5000,
          maxRetries: 3,
          minReserveWeth: 10,
          wethAddress: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
        },
        detector: {
          minProfitThreshold: 0.01,
          maxSlippage: 0.005,
          defaultInputAmount: 10,
          gasPriceGwei: 0.1,
          gasPerSwap: 150000,
        },
        logLevel: "info",
      };

      process.env.DRY_RUN = "false";
      process.env.SHADOW_MODE = "true";

      expect(() => new FlashloanBot(config, false, undefined)).toThrow("Wallet is required");

      delete process.env.DRY_RUN;
      delete process.env.SHADOW_MODE;
    });
  });
});
```

**Coverage:**
1. Shadow mode instantiation (engine, builder, nonce manager initialized)
2. Live mode instantiation (all components initialized)
3. Nonce manager syncs with on-chain nonce on initialization
4. Error handling (missing wallet in shadow/live mode)

**Note:** These tests require a local Arbitrum fork running. If the fork is not available, the tests will skip gracefully. To run the fork:
```bash
anvil --fork-url https://arb1.arbitrum.io/rpc --chain-id 42161
```
  </action>
  <verify>
1. `pnpm test -- --run bot/__tests__/integration/live-execution.test.ts` passes (or skips if fork not available)
2. Test file has minimum 4 test cases
3. All tests validate component initialization in shadow/live modes
  </verify>
  <done>
Live execution integration test file exists with tests for shadow mode instantiation, live mode instantiation, nonce manager synchronization, and error handling. Tests run against a local Arbitrum fork when available.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` — no type errors
2. `pnpm test -- --run bot/__tests__/integration/live-execution.test.ts` — all integration tests pass (or skip if fork unavailable)
3. `pnpm test -- --run bot/__tests__/integration/shadow-mode.test.ts` — all shadow mode tests pass
4. `pnpm test -- --run bot/__tests__/unit/nonce-manager.test.ts` — all nonce manager tests pass
5. `pnpm test` — all existing tests still pass (no regressions)
6. `grep -n "new ExecutionEngine" bot/src/index.ts` shows engine initialization in FlashloanBot
7. `grep -n "executeTransaction" bot/src/index.ts` shows live execution call
8. `grep -n "simulateTransaction" bot/src/index.ts` shows shadow mode simulation
9. `cat .env.arbitrum-mainnet` shows SHADOW_MODE, PRIVATE_KEY, EXECUTOR_ADDRESS docs
</verification>

<success_criteria>
FlashloanBot wires ExecutionEngine, TransactionBuilder, and NonceManager in shadow/live modes. Shadow mode simulates transactions via eth_call and logs results without broadcasting. Live mode enforces staleness guard, acquires crash-safe nonces, and submits real transactions. run-arb-mainnet.ts supports all three modes (dry-run, shadow, live). All integration tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/07-live-execution-safety/07-03-SUMMARY.md`
</output>
