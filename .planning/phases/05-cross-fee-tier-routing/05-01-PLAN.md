---
phase: 05-cross-fee-tier-routing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/src/config/chains/pools/arbitrum-mainnet.ts
  - bot/__tests__/config/arbitrum-pools.test.ts
autonomous: true
requirements:
  - ROUTE-03
  - ROUTE-01

must_haves:
  truths:
    - "All 5 major token pairs (WETH/USDC, WETH/USDT, ARB/WETH, LINK/WETH, GMX/WETH) have at least 2 pools with different fee tiers in the pool config"
    - "Each new pool entry has verified on-chain token0/token1 ordering (lower hex address = token0)"
    - "Pool config test validates cross-fee-tier coverage for all 5 major pairs"
  artifacts:
    - path: "bot/src/config/chains/pools/arbitrum-mainnet.ts"
      provides: "Expanded pool definitions with cross-fee-tier pairs"
      contains: "WETH/USDT UniV3 (0.3%)"
    - path: "bot/__tests__/config/arbitrum-pools.test.ts"
      provides: "Tests verifying cross-fee-tier pool coverage and token ordering"
      min_lines: 40
  key_links:
    - from: "bot/src/config/chains/pools/arbitrum-mainnet.ts"
      to: "bot/src/config/chains/arbitrum.ts"
      via: "import ARBITRUM_MAINNET_POOLS"
      pattern: "ARBITRUM_MAINNET_POOLS"
    - from: "bot/__tests__/config/arbitrum-pools.test.ts"
      to: "bot/src/config/chains/pools/arbitrum-mainnet.ts"
      via: "import ARBITRUM_MAINNET_POOLS"
      pattern: "ARBITRUM_MAINNET_POOLS"
---

<objective>
Expand the Arbitrum mainnet pool config so all 5 major token pairs have cross-fee-tier coverage, and add tests verifying the coverage matrix.

Purpose: The bot currently monitors 22 pools, but WETH/USDT has only one fee tier (0.05%) and LINK/WETH has only one fee tier (0.3%). Without cross-fee-tier pairs, these token pairs cannot produce sub-0.60% cost floor opportunities. Adding the missing fee tier pools completes the pair matrix.

Output: Updated pool config with 2+ fee tiers per major pair, plus test file validating coverage.
</objective>

<execution_context>
@/Users/naynay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naynay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@bot/src/config/chains/pools/arbitrum-mainnet.ts
@bot/src/config/chains/arbitrum.ts
@bot/src/config/types.ts
@bot/src/monitor/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Discover and add missing cross-fee-tier pools to config</name>
  <files>bot/src/config/chains/pools/arbitrum-mainnet.ts</files>
  <action>
Add the missing fee-tier pool entries for WETH/USDT and LINK/WETH so each of the 5 major pairs has cross-fee-tier coverage.

**Current coverage gaps:**
- WETH/USDT: has UniV3 0.05% only. Need UniV3 0.3% pool.
- LINK/WETH: has UniV3 0.3% + SushiV3 0.3% only. Need a different fee tier (0.05% on UniV3, or a Camelot/SushiV2 pool).

**Discovery approach — use Uniswap V3 factory getPool():**
The Uniswap V3 factory on Arbitrum is `0x1F98431c8aD98523631AE4a59f267346ea31F984`. Use `cast call` (Foundry) to discover pool addresses:

```bash
# WETH/USDT UniV3 0.3% (fee=3000)
cast call 0x1F98431c8aD98523631AE4a59f267346ea31F984 \
  "getPool(address,address,uint24)(address)" \
  0x82af49447d8a07e3bd95bd0d56f35241523fbab1 \
  0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9 \
  3000 --rpc-url $RPC_URL

# LINK/WETH UniV3 0.05% (fee=500)
cast call 0x1F98431c8aD98523631AE4a59f267346ea31F984 \
  "getPool(address,address,uint24)(address)" \
  0x82af49447d8a07e3bd95bd0d56f35241523fbab1 \
  0xf97f4df75117a78c1a5a0dbb814af92458539fb4 \
  500 --rpc-url $RPC_URL
```

If a pool returns `0x0000...0000`, it does not exist. In that case, check SushiSwap V3 factory (`0x1af415a1EbA07a4986a52B6f2e7dE7003D82231e`) with the same call, or add a V2/Camelot pool at a different fee tier.

**For each discovered pool, verify token0/token1 ordering:**
```bash
cast call <POOL_ADDRESS> "token0()(address)" --rpc-url $RPC_URL
cast call <POOL_ADDRESS> "token1()(address)" --rpc-url $RPC_URL
```

Token0 MUST be the lower hex address. This is critical — incorrect ordering produces inverted prices.

**Also verify the pool has non-zero liquidity:**
```bash
cast call <POOL_ADDRESS> "liquidity()(uint128)" --rpc-url $RPC_URL
```

If liquidity is 0, the pool exists but has no active positions — skip it (add a comment explaining why, like the PREMIA pool pattern).

**Add each new pool entry following the existing pattern:**
```typescript
{
  label: "WETH/USDT UniV3 (0.3%)",
  dex: "uniswap_v3",
  poolAddress: "<discovered address>",
  token0: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1", // WETH (verify!)
  token1: "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9", // USDT (verify!)
  decimals0: 18,
  decimals1: 6,
  feeTier: 3000,
},
```

Place each new entry in the correct token-pair section (WETH/USDT or LINK/WETH), below the existing entries for that pair.

**Important:** If `cast` is not available in the sandbox, fall back to using the known pool addresses from Uniswap V3 subgraph or Arbiscan. Common addresses:
- WETH/USDT UniV3 0.3%: `0xc82819F72A9e77E2136517C82d6eD4fAbA6436ac` (verify token ordering!)
- LINK/WETH UniV3 0.05%: check if exists; if not, note it in a comment and rely on SushiV3 0.3% + UniV3 0.3% as the cross-DEX pair

If a pool cannot be found at a different fee tier, document it with a comment (like the PREMIA/SPELL comments) explaining the gap and what alternatives were checked.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes (no type errors in pool config)
2. Count pool entries in the WETH/USDT section — must be >=2
3. Count distinct fee tiers across LINK/WETH section — should have >1 fee tier OR cross-DEX coverage
4. All pool addresses are 42-character hex strings starting with 0x
5. All token0 addresses are lexicographically lower than token1 addresses (or match the on-chain ordering)
  </verify>
  <done>
WETH/USDT has 2+ pools with different fee tiers. LINK/WETH has 2+ pools covering different fee tiers or DEXes. All new entries have correct token ordering verified against on-chain data. Pool config compiles without type errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pool coverage tests for cross-fee-tier matrix</name>
  <files>bot/__tests__/config/arbitrum-pools.test.ts</files>
  <action>
Create a new test file `bot/__tests__/config/arbitrum-pools.test.ts` that validates the cross-fee-tier coverage matrix for all 5 major token pairs.

**Test structure:**

```typescript
import { describe, it, expect } from "vitest";
import { ARBITRUM_MAINNET_POOLS } from "../../src/config/chains/pools/arbitrum-mainnet.js";
```

**Tests to write:**

1. **"should have at least 2 pools for each major token pair"** — Group pools by token pair (normalize to sorted lowercase addresses). For each of WETH/USDC, WETH/USDT, ARB/WETH, LINK/WETH, GMX/WETH, assert the group has >= 2 pools.

2. **"should have cross-fee-tier coverage for WETH/USDC"** — Filter to WETH/USDC pools, extract distinct feeTier values (treating undefined as "v2-0.3%"). Assert at least 2 distinct fee tiers (e.g., 500 and 3000).

3. **"should have cross-fee-tier coverage for WETH/USDT"** — Same pattern for WETH/USDT.

4. **"should have cross-fee-tier or cross-DEX coverage for ARB/WETH"** — Assert ARB/WETH pools span 2+ distinct fee tiers OR 2+ distinct DEX protocols.

5. **"should have cross-fee-tier or cross-DEX coverage for LINK/WETH"** — Same for LINK/WETH.

6. **"should have cross-fee-tier coverage for GMX/WETH"** — Assert GMX/WETH pools have 2+ distinct fee tiers.

7. **"all pools should have token0 address < token1 address (on-chain ordering)"** — For every pool in the config, verify `pool.token0.toLowerCase() < pool.token1.toLowerCase()` OR that the ordering matches the known on-chain contract. (Note: some pools like MAGIC/WETH have MAGIC as token0 because `0x539b...` < `0x82af...`. This is correct.)

8. **"all pool addresses should be valid checksummed hex strings"** — Verify each poolAddress matches `/^0x[0-9a-fA-F]{40}$/`.

**Helper function for pair grouping:**
```typescript
function pairKey(pool: { token0: string; token1: string }): string {
  const [a, b] = [pool.token0.toLowerCase(), pool.token1.toLowerCase()].sort();
  return `${a}/${b}`;
}
```

**Token addresses for the 5 major pairs** (from arbitrum.ts):
```typescript
const WETH = "0x82af49447d8a07e3bd95bd0d56f35241523fbab1";
const USDC = "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8";
const USDT = "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9";
const ARB  = "0x912ce59144191c1204e64559fe8253a0e49e6548";
const LINK = "0xf97f4df75117a78c1a5a0dbb814af92458539fb4";
const GMX  = "0xfc5a1a6eb076a2c7ad06ed22c90d7e710e35ad0a";
```

Use the same `pairKey()` function to generate expected keys and look them up in the groups.
  </action>
  <verify>
`pnpm test -- --run bot/__tests__/config/arbitrum-pools.test.ts` passes with all tests green. At minimum: 8 test cases passing.
  </verify>
  <done>
Test file exists at `bot/__tests__/config/arbitrum-pools.test.ts` with 8+ passing tests that validate cross-fee-tier coverage for all 5 major token pairs and correct token ordering for all pools.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` — no type errors
2. `pnpm test -- --run bot/__tests__/config/arbitrum-pools.test.ts` — all pool coverage tests pass
3. `pnpm test` — all existing tests still pass (no regressions)
4. Count of pools in ARBITRUM_MAINNET_POOLS >= 23 (was 22, added at least 1)
5. Every major pair (WETH/USDC, WETH/USDT, ARB/WETH, LINK/WETH, GMX/WETH) has pools spanning 2+ fee tiers or 2+ DEX protocols
</verification>

<success_criteria>
All 5 major token pairs have cross-fee-tier pool coverage in the config, validated by passing tests. Existing tests unbroken. New pool entries have verified on-chain token ordering.
</success_criteria>

<output>
After completion, create `.planning/phases/05-cross-fee-tier-routing/05-01-SUMMARY.md`
</output>
